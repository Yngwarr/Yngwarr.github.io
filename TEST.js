function clear_text(text)
{
	return text.replace(/[,]/g, '')
			   .replace(/[.]/g, '')
			   .replace(/[:]/g, '')
			   .replace(/[;]/g, '')
			   .replace(/[?]/g, '')
			   .replace(/[!]/g, '')
			   .replace(/[-]/g, '')
			   .replace(/["]/g, '')
			   .replace(/[']/g, '')
         .replace(/[«]/g, '')
         .replace(/[»]/g, '')
			   .replace(/[(]/g, '')
			   .replace(/[)]/g, '')
			   .replace(/[=]/g, '')
			   .replace(/[`]/g, '')
			   .replace(/[+]/g, '')
         .replace(/[\/p]/g, '')
         .replace(/[\/ p]/g, '')
         .replace(/[&ns]/g, '')
         .replace(/[&shy;]/g, '')
			   .replace(/[-]/g, '')
         .replace(/[\n]/g, '')
         .replace(/[\t]/g,'')
			   .replace(/[< br>]/g, '')
			   .replace(/[<br >]/g, '')
         .replace(/[<br>]/g, '')
         .replace(/[< br >]/g, '')
			   .replace(new RegExp(String.fromCharCode(8212), 'g'), '')
         .replace(new RegExp(String.fromCharCode(8211), 'g'), '')
         .replace(new RegExp(String.fromCharCode(95), 'g'), '')
         .replace(new RegExp(String.fromCharCode(171), 'g'), '')
         .replace(new RegExp(String.fromCharCode(187), 'g'), '')
         .replace(new RegExp(String.fromCharCode(160), 'g'), '')
			   .toLowerCase()
         .replace(/[ ]/g,'');
}

function main() 
{
    console.log('injecting...');
        let t = document.getElementsByClassName('text custom-footer')[0].getElementsByTagName('p')[0].innerHTML = 'Подключено';
    console.log('sussed inject');

    console.log('\t get question');
    var question_t = document.getElementsByClassName('question-prompt')[0].innerText;
    console.log('\t susses get question:\n' + question_t);

    console.log('\thasing question');
    var hash_quest = clear_text(question_t);
    console.log('\thash:\n' + hash_quest);

    console.log('\tfind answer...');
    if (hash_quest in answers) {
        var dom_questions = document.getElementsByClassName('question-choices visible-correct-response')[0].getElementsByClassName('choice');
        for (var i = 0; i < dom_questions.length; i++){
            for(var j = 0; j < answers[hash_quest].length; j++) {
                var text_answer = clear_text(dom_questions[i].getElementsByTagName('label')[0].getElementsByTagName('span')[0].innerText);
                if (text_answer === answers[hash_quest][j]) {
                    dom_questions[i].getElementsByTagName('input')[0].checked = true;
                    break;
                } 
            }
        }
    } else {
       console.log('\t\tanswer not found ;(');
        return;
    }
    console.log('\tfind answer end');
}

var answers = {};

// Спецификация требований

{
  let t = clear_text('Функциональные требования определяют');
	answers[t] = [clear_text('действия системы без учета ограничений, связанных с ее реализацией'),clear_text('действия, которые должна выполнять система')];	
}
{
  let t = clear_text('Функциональныех требования к системе можно выразить');
	answers[t] = [clear_text('в форме вариантов использования и системных свойств'),clear_text('в форме системных свойств')];	
}
{
  let t = clear_text('Все требования к ПО делятся на');
	answers[t] = [clear_text('функциональные'),clear_text('не функциональные')];	
}
{
  let t = clear_text('Выявленные требования к ПО оформляются в виде ряда документов и моделей. К основным документам, регламентируемым технологией Rational Unified Process, предназначенным для оформления требований относятся:');
	answers[t] = [clear_text('Дополнительные спецификации (технические требования)'),clear_text('Концепция'),clear_text('Словарь предметной области (глоссарий)')];	
}
{
  let t = clear_text('Практичность определяется следующими факторами');
	answers[t] = [clear_text('эстетикой'),clear_text('легкостью изучения и использования'),clear_text('согласованностью пользовательского интерфейса, пользовательской документации и обучающих материалов')];	
}
{
  let t = clear_text('При переходе от бизнес-модели к начальной версии модели вариантов использования применяются следующие правила.');
	answers[t] = [clear_text('В состав действующих лиц включаются внешние системы, играющие в бизнес-процессах пассивную роль источников информации.'),clear_text('Для каждого исполнителя в модели бизнес-анализа, который в перспективе станет пользователем новой системы, в модели вариантов использования создается действующее лицо с таким же наименованием.'),clear_text('Варианты использования для данного действующего лица создаются на основе анализа обязанностей соответствующего исполнителя (в простейшем случае для каждой операции исполнителя создается вариант использования, реализующий данную операцию в системе).')];	
}
{
  let t = clear_text('Не функциональные требования описывают');
	answers[t] = [clear_text('атрибуты системы (технические характеристики) и ее окружения	')];	
}
{
  let t = clear_text('Концепция как один из основных документов, выражающий требования к ПО, определяет');
	answers[t] = [clear_text('постановку задачи разработки, определяющую требования к выполняемым системой функциям'),clear_text('основные особенности разрабатываемой системы'),clear_text('глобальные цели проекта')];	
}
{
  let t = clear_text('Вариант использования (use case) в контексте процесса управления требованиями трактуется следующим образом:');
	answers[t] = [clear_text('основное действующее лицо инициирует взаимодействие с системой, чтобы добиться некоторой цели. Система отвечает, соблюдая интересы всех участников'),clear_text('вариант использования описывает поведение системы при различных условиях, когда система отвечает на запрос одного из участников, называемого основным действующим лицом'),clear_text('фиксирует соглашение между участниками проекта относительно поведения системы')];	
}
{
  let t = clear_text('Существуют четыре уровня точности при описании вариантов использования (расположенные по степени повышения точности):');
	answers[t] = [clear_text('Обработка отказа (написание альтернативных потоков событий)'),clear_text('Действующие лица и цели (перечисляются действующие лица и все их цели, которые будет обеспечивать система)'),clear_text('Условия отказа (анализ мест возникновения возможных ошибок в основном потоке событий)'),clear_text('Краткое изложение варианта использования (в один абзац) или основной поток событий (без анализа возможных ошибок)')];	
}
{
  let t = clear_text('Спецификация требований в технологии Rational Unified Process _____ обязательного моделирования бизнес-процес­сов организации, для которых создается ПО.');
	answers[t] = [clear_text('не требует')];	
}
{
  let t = clear_text('Для выявления требований не используется');
	answers[t] = [clear_text('метод экспертных оценок')];	
}
{
  let t = clear_text('Категории FURPS для не функциональных требований включают в себя');
	answers[t] = [clear_text('Возможность поддержки'),clear_text('Производительность'),clear_text('Надежность'),clear_text('Практичность')];	
}
{
  let t = clear_text('Функциональные требования к системе моделируются и документируются с помощью');
	answers[t] = [clear_text('вариантов использования (use case)')];	
}
{
  let t = clear_text('Требования производительности накладывают ограничения на функциональные требования. Например, требование, задающее для транзакций');
	answers[t] = [clear_text('время восстановления'),clear_text('скорость'),clear_text('время отклика'),clear_text('частота'),clear_text('точность')];	
}
{
  let t = clear_text('Возможность поддержки связана с возможностью');
	answers[t] = [clear_text('параметрами качества, необходимыми для обновления системы после ее выпуска'),clear_text('эксплуатации'),clear_text('тестирования')];	
}
{
  let t = clear_text('Требования надежности связаны с');
	answers[t] = [clear_text('предсказуемостью и точностью'),clear_text('возможностью восстановления'),clear_text('частотой появления и серьезностью ошибок')];	
}

//UML

{
  let t = clear_text('Диаграмма размещения отражает');
	answers[t] = [clear_text('физические взаимосвязи между программными и аппаратными компонентами системы')];	
}
{
  let t = clear_text('Основные элементы диаграммы размещения:');
	answers[t] = [clear_text('соединение (connection) - канал взаимодействия узлов (сеть)'),clear_text('узел (node) — вычислительный ресурс — процессор или другое устройство (дисковая память, контроллеры различных устройств и т.д.)	')];	
}
{
  let t = clear_text('Требование (requirement) - это _______________, _______________ или _______, которым должна удовлетворять система в процессе своей эксплуатации');
	answers[t] = [clear_text('Условие'),clear_text('Характеристика'),clear_text('желательное свойство')];	
}
{
  let t = clear_text('Укажите элементы, которые не используется на диаграммах вариантов использования');
	answers[t] = [clear_text('Прецеденты'),clear_text('основной поток событий'),clear_text('альтернативный поток событий')];	
}
{
  let t = clear_text('Модель вариантов использования хорошо вписывается в');
	answers[t] = [clear_text('объектно-ориентированные'),clear_text('любые методы проектирования'),clear_text('структурные')];	
}
{
  let t = clear_text('Обычно описание потока событий (сценария варианта использования) включает следующие разделы:');
	answers[t] = [clear_text('альтернативные потоки событий'),clear_text('расширения (extensions)'),clear_text('предусловия (pre-conditions)'),clear_text('постусловия (post-conditions)'),clear_text('краткое описание'),clear_text('основной поток событий')];	
}
{
  let t = clear_text('Вариант использования представляет собой последовательность действий (транзакций),выполняемых ________ в ответ на событие, инициируемое _______.');
	answers[t] = [clear_text('действующим лицом'),clear_text('системой')];	
}
{
  let t = clear_text('Какие дополнительные требования входят в классификацию требований модели FURPS+?');
	answers[t] = [clear_text('физические требования'),clear_text('требования к графическому интерфейсу пользователя')];	
}
{
  let t = clear_text('Действующие лица диаграммы вариантов использования делятся на три основных типа ');
	answers[t] = [clear_text('другие системы, взаимодействующие с данной'),clear_text('время'),clear_text('пользователи системы')];	
}
{
  let t = clear_text('На диаграмме состояний имеются два специальных состояния —');
	answers[t] = [clear_text('начальное (start)'),clear_text('конечное (stop)')];	
}
{
  let t = clear_text('Диаграммы состояний отображают');
	answers[t] = [clear_text('все возможные состояния, в которых может находиться конкретный объект'),clear_text('процесс смены состояний объекта в результате наступления некоторых событий')];	
}
{
  let t = clear_text('С состоянием диаграммы состояний можно связывать данные пяти типов:');
	answers[t] = [clear_text('входное действие'),clear_text('выходное действие'),clear_text('событие'),clear_text('деятельность'),clear_text('история состояния')];	
}
{
  let t = clear_text('Выходное действие (exit action) на диаграмме состояний');
	answers[t] = [clear_text('осуществляется как составная часть процесса выхода из данного состояния'),clear_text('является непрерываемым'),clear_text('изображают внутри состояния, ему предшествует слово exit (выход) и двоеточие')];	
}
{
  let t = clear_text('Деятельность (activity) (на диаграмме состояний) – это');
	answers[t] = [clear_text('она может выполняться до своего завершения, пока объект находится в данном состоянии'),clear_text('прерываемое поведение'),clear_text('изображают внутри самого состояния'),clear_text('ей должно предшествовать слово do (выполнять) и двоеточие')];	
}
{
  let t = clear_text('Диаграммы состояний');
	answers[t] = [clear_text('не надо создавать для каждого класса'),clear_text('надо создавать, если объект класса может существовать в нескольких состояниях и в каждом из них ведет себя по-разному')];	
}
{
  let t = clear_text('Ограничивающие условия (guard conditions) обладают следующими особенностями');
	answers[t] = [clear_text('задавать необязательно, если нет автоматических переходов'),clear_text('определяют, когда переход может, а когда не может осуществиться'),clear_text('изображают на диаграмме вдоль линии перехода после имени события, заключая их в квадратные скобки'),clear_text('если существует несколько автоматических переходов из состояния, необходимо определить для них взаимно исключающие ограждающие условия')];	
}
{
  let t = clear_text('Действие на диаграмме состояний');
	answers[t] = [clear_text('может быть частью перехода'),clear_text('изображают вдоль линии перехода после имени события, ему предшествует косая черта')];	
}
{
  let t = clear_text('На диаграмме состояний может быть');
	answers[t] = [clear_text('только одно начальное состояние'),clear_text('ноль и более конечных состояний')];	
}
{
  let t = clear_text('У перехода на диаграмме состояний существует несколько спецификаций, основными из которых являются');
	answers[t] = [clear_text('События'),clear_text('ограждающие условия'),clear_text('действия')];	
}
{
  let t = clear_text('Событие (event) обладает следующими особенностями');
	answers[t] = [clear_text('вызывает переход из одного состояния в другое'),clear_text('бывают автоматические переходы, не имеющие событий'),clear_text('размещают на диаграмме вдоль линии перехода'),clear_text('для отображения события на диаграмме можно использовать как имя операции, так и обычную фразу')];	
}
{
  let t = clear_text('Входное действие (entry action) на диаграмме состояний —');
	answers[t] = [clear_text('часть перехода в данное состояние'),clear_text('выполняется, когда объект переходит в данное состояние'),clear_text('непрерываемое'),clear_text('показывают внутри состояния, ему предшествует слово entry (вход) и двоеточие')];	
}
{
  let t = clear_text('Укажите элементы, которые не используются в диаграммах последовательности');
	answers[t] = [clear_text('Агрегация'),clear_text('Композиция ')];	
}
{
  let t = clear_text('Укажите элементы, которые не используются в диаграммах кооперации');
	answers[t] = [clear_text('альтернативный поток событий'),clear_text('основной поток событий'),clear_text('линия жизни')];	
}
{
  let t = clear_text('Диаграмма взаимодействия описывает поведение взаимодействующей группы объектов в рамках');
	answers[t] = [clear_text('потока событий варианта использования'),clear_text('некоторой операции класса')];	
}
{
  let t = clear_text('На диаграмме компонентов изображаются');
	answers[t] = [clear_text('компоненты ПО'),clear_text('связи между компонентами')];	
}
{
  let t = clear_text('На диаграмме компонентов изображают зависимости между отдельными компонентами, соответствующие зависимостям');
	answers[t] = [clear_text('на этапе выполнения'),clear_text('на этапе компиляции')];	
}
{
  let t = clear_text('Стереотипы классов UML — это механизм, позволяющий разделять классы на категории. Например, основными стереотипами, используемыми в процессе анализа системы, являются:');
	answers[t] = [clear_text('Entity (сущность)'),clear_text('Boundary (граница)'),clear_text('Control (управление)')];	
}
{
  let t = clear_text('К механизмам расширения UML относятся:');
	answers[t] = [clear_text('Стереотипы'),clear_text('тегированные (именованные) значения'),clear_text('ограничения')];	
}
{
  let t = clear_text('Именованное значение в UML — это');
	answers[t] = [clear_text('«тег = значение»'),clear_text('«имя — содержимое» ')];	
}
{
  let t = clear_text('Ограничение в UML — это семантическое ограничение, имеющее вид');
	answers[t] = [clear_text('текстового выражения на формальном языке (OCL - Object Constraint Language)'),clear_text('текстового выражения на естественном языке')];	
}
{
  let t = clear_text('Диаграммы деятельности полезны');
	answers[t] = [clear_text('при параллельном программировании'),clear_text('для описания потоков событий в вариантах использования'),clear_text('в описании поведения, включающего большое количество параллельных процессов')];	
}
{
  let t = clear_text('Деятельность на диаграмме деятельности зависит от той точки зрения, с которой строится диаграмма. Это может быть');
	answers[t] = [clear_text('операция класса'),clear_text('некоторая задача, которую необходимо выполнить вручную или автоматизированным способом')];	
}
{
  let t = clear_text('Поток объектов на диаграмме деятельности отмечается');
	answers[t] = [clear_text('пунктирной линией со стрелкой от деятельности к изменяемому объекту'),clear_text('пунктирной линией со стрелкой от объекта к деятельности, использующей объект')];	
}
{
  let t = clear_text('Диаграммы деятельности предпочтительнее использовать в следующих ситуациях:');
	answers[t] = [clear_text('анализ потоков событий в конкретном варианте использования'),clear_text('анализ потоков событий в различных вариантах использования')];	
}
{
  let t = clear_text('Линейки синхронизации на диаграмме деятельности используются, если необходимо');
	answers[t] = [clear_text('показать, что две или более ветвей потока выполняются параллельно')];	
}
{
  let t = clear_text('Показ объектов и их состояний на диаграмме деятельности помогает понять,');
	answers[t] = [clear_text('когда и как происходит смена состояний объекта')];	
}
{
  let t = clear_text('На диаграмме деятельности могут присутствовать');
	answers[t] = [clear_text('объекты и потоки объектов')];	
}
{
  let t = clear_text('Основным элементом диаграммы деятельности является');
	answers[t] = [clear_text('деятельность (activity)')];	
}
{
  let t = clear_text('Любая диаграмма деятельности должна иметь');
	answers[t] = [clear_text('начальную точку')];	
}
{
  let t = clear_text('На диаграммах деятельности объекты связаны с деятельностями через');
	answers[t] = [clear_text('потоки объектов')];	
}
{
  let t = clear_text('Стереотипы UML расширяют нотацию модели, могут применяться');
	answers[t] = [clear_text('к любым элементам модели')];	
}
{
  let t = clear_text('Стереотип UML — это ');
	answers[t] = [clear_text('новый тип элемента модели')];	
}
{
  let t = clear_text('Стереотип UML — это новый тип элемента модели, который');
	answers[t] = [clear_text('определяется на основе уже существующего элемента')];	
}
{
  let t = clear_text('Информационное (informative) сообщение — сообщение,');
	answers[t] = [clear_text('снабжающее объект-получатель некоторой информацией для обновления его состояния')];	
}
{
  let t = clear_text('Укажите верное. Сообщение (message) —');
	answers[t] = [clear_text('средство, с помощью которого объект-отправитель запрашивает у объекта-получателя выполнение одной из его операций')];	
}
{
  let t = clear_text('Сообщение-запрос (interrogative) — сообщение,');
	answers[t] = [clear_text('запрашивающее выдачу некоторой информации об объекте-получателе ')];	
}
{
  let t = clear_text('К диаграммам взаимодействия не относится');
	answers[t] = [clear_text('диаграммы деятельности')];	
}
{
  let t = clear_text('Порядок передачи сообщений на диаграмме последовательности -');
	answers[t] = [clear_text('сверху вниз')];	
}
{
  let t = clear_text('Императивное (imperative) сообщение - сообщение,');
	answers[t] = [clear_text('запрашивающее у объекта-получателя выполнение некоторых действий')];	
}
{
  let t = clear_text('Порядок передачи сообщений на диаграмме кооперации -');
	answers[t] = [clear_text('задан номерами сообщений')];	
}
{
  let t = clear_text('Укажите неверное. Сообщения (message), которыми обмениваются объекты, могут быть');
	answers[t] = [clear_text('событийными (event)')];	
}
{
  let t = clear_text('Диаграммы последовательности отображают');
	answers[t] = [clear_text('временную последовательность событий, происходящих в рамках варианта использования')];	
}
{
  let t = clear_text('Укажите, что не может быть действующим лицом для системы');
	answers[t] = [clear_text('прецедент	')];	
}
{
  let t = clear_text('Укажите связь, которая не используется в диаграммах вариантов использования');
	answers[t] = [clear_text('Агрегация')];	
}
{
  let t = clear_text('Связь _______ — это связь между вариантом использования и действующим лицом.');
	answers[t] = [clear_text('коммуникации')];	
}
{
  let t = clear_text('Связь _______ применяется при наличии изменений в нормальном поведении системы, которые также выносятся в отдельный вариант использования.');
	answers[t] = [clear_text('расширения')];	
}
{
  let t = clear_text('Цель построения диаграмм вариантов использования —');
	answers[t] = [clear_text('документирование функциональных требований к системе в самом общем виде')];	
}
{
  let t = clear_text('Укажите, что не является достоинством модели вариантов использования');
	answers[t] = [clear_text('отображает взаимодействующие классы')];	
}
{
  let t = clear_text('Укажите, что не определяет диаграмма прецедентов');
	answers[t] = [clear_text('последовательность выполнения прецедентов во времени')];	
}
{
  let t = clear_text('Какое определение шаблона сценария правильно в контексте языка UML?');
	answers[t] = [clear_text('Неформальные рекомендации по структуризации текста сценария варианта использования')];	
}
{
  let t = clear_text('Укажите раздел, который не входит в описание потока событий прецедента');
	answers[t] = [clear_text('включаемые прецеденты')];	
}
{
  let t = clear_text('С помощью связи _______ показывают, что у нескольких действующих лиц имеются общие черты и различия.');
	answers[t] = [clear_text('Обобщения')];	
}
{
  let t = clear_text('Связь _______ применяется в тех ситуациях, когда имеется какой-либо фрагмент поведения системы (часть потока событий), который повторяется более чем в одном варианте использования.');
	answers[t] = [clear_text('включения')];	
}



// Анализ проектирования ПО

{
  let t = clear_text('Первым действием архитектора при выявлении подсистем является преобразование классов анализа в проектные классы (design classes). По каждому классу анализа принимается одно из двух решений:');
	answers[t] = [clear_text('сложный класс анализа может быть разбит на несколько классов, преобразован в пакет или в подсистему'),clear_text('класс анализа отображается в проектный класс, если он простой или представляет единственную логическую абстракцию')];	
}
{
  let t = clear_text('Проектирование архитектуры системы выполняется архитектором системы и включает в себя:');
	answers[t] = [clear_text('анализ взаимодействий между классами анализа, выявление подсистем и интерфейсов'),clear_text('проектирование конфигурации системы'),clear_text('идентификацию архитектурных решений и механизмов, необходимых для проектирования системы'),clear_text('проектирование структуры потоков управления'),clear_text('формирование архитектурных уровней')];	
}
{
  let t = clear_text('Проектирование классов включает следующие действия:');
	answers[t] = [clear_text('детализация проектных классов'),clear_text('уточнение связей между классами'),clear_text('уточнение операций и атрибутов'),clear_text('моделирование состояний для объектов классов')];	
}
{
  let t = clear_text('Объектно-ориентированное проектирование включает два вида деятельности:');
	answers[t] = [clear_text('проектирование элементов системы'),clear_text('проектирование архитектуры системы ')];	
}
{
  let t = clear_text('Проектирование структуры потоков управления выполняется');
	answers[t] = [clear_text('при наличии в системе параллельных процессов (параллелизма)')];	
}
{
  let t = clear_text('Проектирование элементов системы выполняется проекти­ровщиками и включает в себя:');
	answers[t] = [clear_text('уточнение описания вариантов использования'),clear_text('проектирование баз данных'),clear_text('проектирование классов')];	
}
{
  let t = clear_text('Классы сущности (Entity) —');
	answers[t] = [clear_text('представляют собой основные абстракции (понятия) разрабатываемой системы, рассматриваемые в рамках конкретного варианта использования')];	
}
{
  let t = clear_text('Объектно-ориентированный анализ включает два вида деятельности:');
	answers[t] = [clear_text('анализ вариантов использования'),clear_text('архитектурный анализ')];	
}
{
  let t = clear_text('Целью объектно-ориентированного анализа является');
	answers[t] = [clear_text('трансформация функциональных требований к ПО в предварительный системный проект'),clear_text('создание стабильной основы архитектуры системы')];	
}
{
  let t = clear_text('Анализ вариантов использования выполняется проектировщиками и включает в себя:');
	answers[t] = [clear_text('определение атрибутов и ассоциаций классов'),clear_text('идентификацию классов, участвующих в реализации потоков событий варианта использования'),clear_text('унификацию классов анализа'),clear_text('распределение поведения, реализуемого вариантом использования, между классами (определение обязанностей классов)')];	
}
{
  let t = clear_text('Управляющие классы  (Control) —');
	answers[t] = [clear_text('обеспечивают координацию поведения объектов в системе')];	
}
{
  let t = clear_text('Архитектура крупномасштабной системы должна удовлетворять следующим требованиям:');
	answers[t] = [clear_text('компоненты системы должны иметь возможность замены'),clear_text('размер компонентов не должен быть слишком большим'),clear_text('изменения в одних компонентах не должны сильно затрагивать другие'),clear_text('однородные функции должны группироваться вместе')];	
}
{
  let t = clear_text('Архитектурные механизмы отражают');
	answers[t] = [clear_text('не функциональные требования к системе'),clear_text('реализацию не функциональных требований в архитектуре системы')];	
}
{
  let t = clear_text('Граничные классы (Boundary) —');
	answers[t] = [clear_text('служат посредниками при взаимодействии внешних объектов с системой')];	
}
{
  let t = clear_text('Соглашения моделирования определяют:');
	answers[t] = [clear_text('правила применения элементов модели'),clear_text('организацию модели (пакеты)'),clear_text('используемые диаграммы и элементы модели'),clear_text('соглашения по именованию элементов модели')];	
}
{
  let t = clear_text('Архитектурный анализ выполняется архитектором системы и включает в себя:');
	answers[t] = [clear_text('формирование начального представления архитектурных уровней'),clear_text('формирование набора основных абстракций предметной области (классов анализа)'),clear_text('предварительное выявление архитектурных механизмов (механизмов анализа)'),clear_text('утверждение общих стандартов (соглашений) моделирования и документирования системы')];	
}
{
  let t = clear_text('В потоках событий варианта использования выявляются классы трех типов');
	answers[t] = [clear_text('Классы-сущности (Entity)'),clear_text('Граничные классы (Boundary)'),clear_text('Управляющие классы (Control)')];	
}

// Жизненный цикл ПО

{
  let t = clear_text('﻿К вспомогательным процессам не относят');
	answers[t] = [clear_text('Приобретение')];	
}
{
  let t = clear_text('Обучение относится к ___________ процессам');
	answers[t] = [clear_text('организационным')];	
}
{
  let t = clear_text('Верификация относится к ___________ процессам');
	answers[t] = [clear_text('вспомогательным')];	
}
{
  let t = clear_text('К основным процессам не относят');
	answers[t] = [clear_text('Документирование')];	
}
{
  let t = clear_text('Международная организация по стандартизации');
	answers[t] = [clear_text('ISO')];	
}
{
  let t = clear_text('Аудит относится к ___________ процессам');
	answers[t] = [clear_text('вспомогательным')];	
}
{
  let t = clear_text('Достоинством спиральной модели не является:');
	answers[t] = [clear_text('на каждой стадии формируется законченный набор проектной документации, отвечающий критериям полноты и согласованности')];	
}
{
  let t = clear_text('Модель ЖЦ программного обеспечения не зависит от');
	answers[t] = [clear_text('состояния рынка программных продуктов')];	
}
{
  let t = clear_text('Обеспечение качества относится к ___________ процессам');
	answers[t] = [clear_text('вспомогательным')];	
}
{
  let t = clear_text('Все входящие в состав НМО документы классифицируются по следующим признакам');
	answers[t] = [clear_text('объекту регламентации или методического обеспечения'),clear_text('виду регламентации'),clear_text('области действия документа'),clear_text('статусу регламентирующего документа')];	
}
{
  let t = clear_text('Международная комиссия по электротехнике');
	answers[t] = [clear_text('IEC')];	
}
{
  let t = clear_text('Нормативной базой НМО являются');
	answers[t] = [clear_text('стандарты организации-заказчика'),clear_text('стандарты Российской Федерации ГОСТ Р'),clear_text('международные стандарты ISO/IEC ')];	
}
{
  let t = clear_text('В стандарте ЖЦ процесс определяется как совокупность взаимосвязанных _________, преобразующих некоторые входные данные в выходные.');
	answers[t] = [clear_text('действий')];	
}
{
  let t = clear_text('Нормативно-методическое обеспечение создания ПО не регламентирует');
	answers[t] = [clear_text('состав и структуру коллектива разработчиков')];	
}
{
  let t = clear_text('Преимущества применения каскадной модели заключаются в следующем:');
	answers[t] = [clear_text('на каждой стадии формируется законченный набор проектной документации, отвечающий критериям полноты и согласованности'),clear_text('выполняемые в логичной последовательности стадии работпозволяют планировать сроки завершения всех работ и соответствующие затраты')];	
}
{
  let t = clear_text('К организационным процессам не относят');
	answers[t] = [clear_text('сопровождение')];	
}
{
  let t = clear_text('Документирование относится к ___________ процессам');
	answers[t] = [clear_text('вспомогательным')];	
}
{
  let t = clear_text('В соответствии со стандартом ГОСТ Р ИСО/МЭК 12207-99 все процессы ЖЦ ПО разделены на три группы');
	answers[t] = [clear_text('Основные процессы'),clear_text('Вспомогательные процессы'),clear_text('Организационные процессы')];	
}
{
  let t = clear_text('Недостатком каскадной модели ЖЦ не является:');
	answers[t] = [clear_text('формирование на каждой стадии законченного набора проектной документации, отвечающий критериям полноты и согласованности')];	
}
{
  let t = clear_text('Аттестация относится к ___________ процессам');
	answers[t] = [clear_text('вспомогательным')];	
}

// Моделирование бизнесс-процессов

{
  let t = clear_text('Модель бизнес-процессов представляет собой расширение модели');
	answers[t] = [clear_text('вариантов использования UML')];	
}
{
  let t = clear_text('Методика построения бизнес-моделей, являющаяся составной частью технологии Rational Unified Process, предусматривает построение двух моделей');
	answers[t] = [clear_text('модели бизнес-процессов (Business Use Case Model)'),clear_text('модели бизнес-анализа (Business Analysis Model)')];	
}
{
  let t = clear_text('Бизнес-процесс использует определенные ресурсы (________, _________, ______, _________) для преобразования входных элементов в выходные');
	answers[t] = [clear_text('информационные'),clear_text('материальные'),clear_text('финансовые'),clear_text('человеческие')];	
}
{
  let t = clear_text('Укажите процесс, который не относится к бизнес-процессам управления');
	answers[t] = [clear_text('администрирование')];	
}
{
  let t = clear_text('Цели построения бизнес-модели');
	answers[t] = [clear_text('обеспечить понимание структуры организации и динамики происходящих в ней процессов'),clear_text('убедиться, что заказчики, пользователи и разработчики, одинаково понимают цели и задачи организации'),clear_text('обеспечить понимание текущих проблем организации и возможностей их решения'),clear_text('создать базу для формирования требований к будущей ПС организации')];	
}
{
  let t = clear_text('Модель бизнес-анализа — объектная модель, описывающая реализацию бизнес-процесса в терминах взаимодействующих объектов (бизнес-объектов — Business Object), принадлежащих к двум классам, —');
	answers[t] = [clear_text('Business Worker'),clear_text('Business Entity')];	
}
{
  let t = clear_text('Укажите процесс, который не относится к обеспечивающим бизнес-процессам');
	answers[t] = [clear_text('формироввание управляющих воздействий')];	
}
{
  let t = clear_text('Важным шагом структуризации деятельности любой организации являются выделение и классификация бизнес-процессов. Можно выделить следующие классы процессов');
	answers[t] = [clear_text('процессы управления'),clear_text('основные процессы'),clear_text('обеспечивающие процессы')];	
}
{
  let t = clear_text('В состав модели бизнес-анализа обязательно должна входить');
	answers[t] = [clear_text('диаграмма классов, содержащая исполнителей и сущности.')];	
}
{
  let t = clear_text('Модель бизнес-анализа может включать');
	answers[t] = [clear_text('кооперативные диаграммы'),clear_text('диаграммы деятельности с потоками объектов и «плавательными дорожками»'),clear_text('диаграммы последовательности'),clear_text('диаграммы состояний'),clear_text('диаграммы классов')];	
}
{
  let t = clear_text('Объектно-ориентированный подход к моделированию бизнес-процессов в технологии Rational Unified Process предусматривает построение двух моделей');
	answers[t] = [clear_text('модели бизнес-процессов (Business Use Case Model)'),clear_text('модели бизнес-анализа (Business Analysis Model')];	
}
{
  let t = clear_text('Модель бизнес-процессов представляет собой расширение модели');
	answers[t] = [clear_text('вариантов использования UML')];	
}
{
  let t = clear_text('Модель бизнес-анализа строится для');
	answers[t] = [clear_text('каждого Business Use Case')];	
}

// Образцы

{
  let t = clear_text('Образец можно определить как');
	answers[t] = [clear_text('общее решение некоторой проблемной ситуации в заданном контексте')];	
}
{
  let t = clear_text('Раздел образца Следствия содержит');
	answers[t] = [clear_text('описание области применения образца'),clear_text('описание недостатков образца'),clear_text('описание достоинст образца')];	
}
{
  let t = clear_text('Наиболее общими категориями образцов ПО являются:');
	answers[t] = [clear_text('образцы поведения'),clear_text('образцы анализа'),clear_text('образцы программирования'),clear_text('образцы проектирования'),clear_text('архитектурные образцы'),clear_text('образцы бизнес-моделирования')];	
}
{
  let t = clear_text('Имя образца позволяет');
	answers[t] = [clear_text('описать проблему проектирования, ее решения и их последствия'),clear_text('проектировать на более высоком уровне абстракции'),clear_text('упоминать образцы в документации'),clear_text('вести обсуждение с коллегами')];	
}
{
  let t = clear_text('В языке UML образец представляется с помощью');
	answers[t] = [clear_text('кооперации')];	
}
{
  let t = clear_text('Раздел образца Проблема содержит');
	answers[t] = [clear_text('формулировку решаемой задачи'),clear_text('перечень условий, при выполнении которых имеет смысл применять данный образец')];	
}
{
  let t = clear_text('Любой образец содержит стандартную диаграмму _______ по названием Участники');
	answers[t] = [clear_text('классов')];	
}
{
  let t = clear_text('В языке UML образец представляется с помощью кооперации со стереотипом');
	answers[t] = [clear_text('«pattern»')];	
}
{
  let t = clear_text('Присваивание образцам имен позволяет проектировать');
	answers[t] = [clear_text('на более низком уровне детализации'),clear_text('на более высоком уровне абстракции')];	
}
{
  let t = clear_text('Достоинства применения образцов при проектировании ПО заключаются в следующем:');
	answers[t] = [clear_text('Ограничение пространства решений'),clear_text('Возможность многократного использования'),clear_text('Повышение эффективности труда отдельных исполнителей и всей группы в целом'),clear_text('Создание модифицируемого и гибкого ПО'),clear_text('Применение единой терминологии')];	
}
{
  let t = clear_text('Раздел образа Решение содержит описание');
	answers[t] = [clear_text('элементов проектного решения'),clear_text('функций элементов решения'),clear_text('связей между элементами проектного решения')];	
}
{
  let t = clear_text('Кооперация (collaboration) определяется как описание совокупности взаимодействующих ________, реализующих некоторое поведение (например, в рамках варианта использования или операции класса)');
	answers[t] = [clear_text('объектов')];	
}
{
  let t = clear_text('Динамическая часть кооперации описывается с помощью одной или нескольких диаграмм');
	answers[t] = [clear_text('взаимодействия')];	
}
{
  let t = clear_text('Образец состоит из четырех основных элементов:');
	answers[t] = [clear_text('следствия'),clear_text('проблема'),clear_text('решение'),clear_text('имя')];	
}
{
  let t = clear_text('Кооперация имеет');
	answers[t] = [clear_text('динамическую часть'),clear_text('статическую часть')];	
}
{
  let t = clear_text('Статическая часть кооперации описывается с помощью диаграммы');
	answers[t] = [clear_text('классов')];	
}

// Сертификация процессов создания ПО

{
  let t = clear_text('СММ представляет собой методический материал, определяющий правила формирования');
	answers[t] = [clear_text('методы постепенного и непрерывного повышения культуры производства'),clear_text('системы управления созданием и сопровождением ПО')];	
}
{
  let t = clear_text('К недостаткам СММ относятся следующие:');
	answers[t] = [clear_text('В модели отсутствует анализ рисков и решений'),clear_text('Не определена область применения модели'),clear_text('Модель сосредоточена исключительно на управлении проектом')];	
}
{
  let t = clear_text('СММ — это описательная модель в том смысле, что она описывает существенные (или ключевые) атрибуты, которые определяют,');
	answers[t] = [clear_text('на каком уровне технологической зрелости находится организация')];	
}
{
  let t = clear_text('Для перехода на уровень "стандартных процессов" необходимо достичь');
	answers[t] = [clear_text('стандартизации процессов')];	
}
{
  let t = clear_text('Укажите уровни технологической зрелости по модели СММ');
	answers[t] = [clear_text('управляемые процессы'),clear_text('оптимизируемые процессы'),clear_text('стандартные процессы'),clear_text('начальный уровень'),clear_text('повторяемые процессы')];	
}
{
  let t = clear_text('Зрелость процессов (software process maturity) — это степень их');
	answers[t] = [clear_text('контролируемости'),clear_text('управляемости'),clear_text('эффективности')];	
}
{
  let t = clear_text('Для перехода на уровень "оптимизируемых процессов" необходимо достичь');
	answers[t] = [clear_text('постоянного совершенствования процессов')];	
}
{
  let t = clear_text('Главное назначение уровня 4 (уровня управляемых процессов)');
	answers[t] = [clear_text('текущий контроль над процессами')];	
}
{
  let t = clear_text('Основное назначение уровня 2 (уровня повторяемых процессов )');
	answers[t] = [clear_text('организация процессов управления проектом')];	
}
{
  let t = clear_text('Сегодня на западе компания-разработчик практически испытывает большие трудности с получением заказов, если она не');
	answers[t] = [clear_text('аттестована по СММ')];	
}
{
  let t = clear_text('Для перехода на уровень "управляемых процессов" необходимо достичь');
	answers[t] = [clear_text('прогнозирования результатов')];	
}
{
  let t = clear_text('Каждый уровень СММ, начиная со второго, характеризуется наличием ряда так называемых основных групп процессов (key process areas - КРА). Модель СММ содержит __ таких групп');
	answers[t] = [clear_text('18')];	
}
{
  let t = clear_text('В модели CMM сформулированы критерии _________ организации');
	answers[t] = [clear_text('совершенства')];	
}
{
  let t = clear_text('Модель СММ -');
	answers[t] = [clear_text('описывает характеристики организации для каждого из уровней технологической зрелости')];	
}
{
  let t = clear_text('Главное назначение уровня 5 (уровня оптимизируемых процессов)');
	answers[t] = [clear_text('последовательное усовершенствование и модернизация процессов создания ПО')];	
}
{
  let t = clear_text('В самом общем виде подход СВР (критически важные практические навы­ки) предлагает:');
	answers[t] = [clear_text('измерять активность разработки'),clear_text('сфокусироваться на количественных параметрах завершения проекта (дате, бюджете, объеме)'),clear_text('измерять продвижение к цели'),clear_text('придумать быстро реализуемую стратегию выполнения проекта')];	
}
{
  let t = clear_text('Для перехода на уровень "повторяемых процессов" необходимо достичь');
	answers[t] = [clear_text('упорядочения процессов')];	
}
{
  let t = clear_text('Начиная с 1990 г. _____ постоянно развивает и совершенствует модель СММ, учитывая все новейшие достижения в области создания и сопровождения ПО.');
	answers[t] = [clear_text('SEI - институт программной инженерии')];	
}
{
  let t = clear_text('Главное назначение уровня 3 (уровня стандартизованных процессов)');
	answers[t] = [clear_text('документирование и стандартизация процессов')];	
}

// Системный подход к проектированию ПО

{
  let t = clear_text('Неотъемлемыми свойствами ПО являются :');
	answers[t] = [clear_text('согласованность'),clear_text('незримость'),clear_text('сложность'),clear_text('изменяемость')];	
}
{
  let t = clear_text('Масштаб определяется (по Алистеру Коберну) количеством разработчиков, участвующих в проекте. В проекте малого масштаба участвуют');
	answers[t] = [clear_text('от 1 до 6 человек')];	
}
{
  let t = clear_text('Изменяемость ПО состоит в том, что');
	answers[t] = [clear_text('его необходимо адаптировать к изменениям технических средств и программного окружения'),clear_text('возникает необходимость у пользователей в расширении его функциональности ')];	
}
{
  let t = clear_text('В основе программной инженерии лежит одна фундаментальная идея: проектирование ПО является');
	answers[t] = [clear_text('формальным процессом, который можно изучать и совершенствовать')];	
}
{
  let t = clear_text('Единицей собираемых требований к ПО в экстремальном программировании XP является');
	answers[t] = [clear_text('«пользовательская история» (user story)')];	
}
{
  let t = clear_text('Масштаб определяется (по Алистеру Коберну) количеством разработчиков, участвующих в проекте. В проекте большого масштаба участвуют');
	answers[t] = [clear_text('свыше 20 человек')];	
}
{
  let t = clear_text('Сложность программных систем порождена');
	answers[t] = [clear_text('большим количеством разных элементов')];	
}
{
  let t = clear_text('Компонент программного комплекса');
	answers[t] = [clear_text('использует точно определённые ресурсы'),clear_text('входные и выходные данные должны удовлетворять точно определённым интерфейсам')];	
}
{
  let t = clear_text('Программная инженерия определяется как дисциплина, изучающая применение строгого систематического количественного (т.е. инженерного) подхода к');
	answers[t] = [clear_text('эксплуатации ПО'),clear_text('разработке ПО'),clear_text('сопровождению ПО')];	
}
{
  let t = clear_text('Масштаб определяется (по Алистеру Коберну) количеством разработчиков,участвующих в проекте. В проекте среднего масштаба участвуют');
	answers[t] = [clear_text('от 6 до 20 человек')];	
}
{
  let t = clear_text('Системный подход — это методология исследования объектов любой природы как систем, которая ориентирована на:');
	answers[t] = [clear_text('сведение этих связей в единую картину'),clear_text('раскрытие целостности объекта и обеспечивающих его механизмов'),clear_text('выявление многообразных типов связей объекта')];	
}
{
  let t = clear_text('Проектированию ПО для того, чтобы стать инженерной дисциплиной, не хватает');
	answers[t] = [clear_text('системы основных принципов')];	
}
{
  let t = clear_text('Согласованность ПО состоит в том, что');
	answers[t] = [clear_text('оно должно согласовываться с уже существующим ПО')];	
}
{
  let t = clear_text('По определению Института управления проектами ( Project Management Institute , PMI ), проект характеризуется следующим');
	answers[t] = [clear_text('временное предприятие'),clear_text('целью проекта - создания уникального продукта или услуги')];	
}
{
  let t = clear_text('«Экстремальное программирование» (Extreme Programming — ХР ) предполагает');
	answers[t] = [clear_text('программы разрабатываются трехнедельными периодами, или итерациями')];	
}
{
  let t = clear_text('Программный продукт');
	answers[t] = [clear_text('может использоваться с различными данными'),clear_text('может использоваться в различных операционных системах'),clear_text('использует и сопровождает любой человек')];	
}
{
  let t = clear_text('Под проектом ПО будем понимать совокупность');
	answers[t] = [clear_text('спецификаций ПО (включающих модели и проектную документацию), обеспечивающих создание ПО в конкретной программно-технической среде')];	
}
{
  let t = clear_text('Укажите продолжение, которое делает высказывание истинным. Проектирование ПО представляет собой процесс создания');
	answers[t] = [clear_text('спецификаций ПО на основе исходных требований к нему')];	
}
{
  let t = clear_text('«Экстремальное программирование» (Extreme Programming — ХР ) предполагает');
	answers[t] = [clear_text('команду от трех до десяти программистов')];	
}
{
  let t = clear_text('Сопровождение ПО может быть');
	answers[t] = [clear_text('корректирующим'),clear_text('адаптирующим'),clear_text('совершенствующим')];	
}
{
  let t = clear_text('Укажите продолжение, которое делает высказывание истинным. Проектирование ПО представляет собой процесс создания');
	answers[t] = [clear_text('спецификаций ПО на основе исходных требований к нему')];	
}
{
  let t = clear_text('Программа');
	answers[t] = [clear_text('запускается автором'),clear_text('запускается в той системе, где была разработана')];	
}
{
  let t = clear_text('разработка ПО изначально');
	answers[t] = [clear_text('является проектированием ')];	
}
{
  let t = clear_text('При разработке ПО в экстремальном программировании (XP)');
	answers[t] = [clear_text('создают модульные тесты и добиваются, чтобы эти тесты выполнялисьй'),clear_text('следуют строгим стандартам кодирования, установленным ими в начале проекта'),clear_text('программисты работают парами')];	
}
{
  let t = clear_text('Программное обеспечение определяется как набор :');
	answers[t] = [clear_text('компьютерных программ'),clear_text('данных'),clear_text('документации'),clear_text('процедур')];	
}
{
  let t = clear_text('По оценке Коберна, быстрая разработка ПО применима только в проектах');
	answers[t] = [clear_text('малого масштаба, критичность D'), clear_text('среднего масштаба, критичность L'),clear_text('малого масштаба, критичность С'),clear_text('среднего масштаба, критичность D'),clear_text('среднего масштаба, критичность С')];	
}

// Методические аспекты проектирования ПО

{
  let t = clear_text('Интерфейс позволяет');
	answers[t] = [clear_text('строить систему более высокого уровня, рассматривая каждую подсистему как единое целое и игнорируя ее внутреннее устройство')];	
}
{
  let t = clear_text('Абстрагирование — это выделение наиболее важных, существенных характеристик ________, которые отличают его от всех других видов объектов, и игнорирование менее важных или незначительных деталей');
	answers[t] = [clear_text('некоторого объекта')];	
}
{
  let t = clear_text('Иерархия — это ранжированная или упорядоченная система абстракций, расположение их __________');
	answers[t] = [clear_text('по уровням')];	
}
{
  let t = clear_text('Инкапсуляция (принцип «черного ящика») позволяет');
	answers[t] = [clear_text('скрыть внутренние ресурсы объекта от внешней среды'),clear_text('отделить устройство объекта от его поведения')];	
}
{
  let t = clear_text('Абстрагирование позволяет');
	answers[t] = [clear_text('управлять сложностью системы'),clear_text('отделить существенные особенности поведения объекта от деталей его реализации')];	
}
{
  let t = clear_text('Инкапсуляция служит для того, чтобы изолировать интерфейс объекта, отражающий его внешнее поведение, от');
	answers[t] = [clear_text('внутренней реализации объекта')];	
}
{
  let t = clear_text('Понятие "связность" применительно к подсистемам означает следующее');
	answers[t] = [clear_text('количество связей между отдельными подсистемами')];	
}
{
  let t = clear_text('CASE-технология представляет собой');
	answers[t] = [clear_text('набор инструментальных средств'),clear_text('совокупность методов проектирования ПО')];	
}
{
  let t = clear_text('Существуют два основных подхода к декомпозиции систем');
	answers[t] = [clear_text('функционально-модульный'),clear_text('объектно-ориентированный')];	
}
{
  let t = clear_text('Понятие «сцепление» по отношению к подсистеме означает');
	answers[t] = [clear_text('связность отдельных частей внутри подсистемы')];	
}
{
  let t = clear_text('Абстрагирование позволяет');
	answers[t] = [clear_text('отделить существенные особенности поведения объекта от деталей его реализации'),clear_text('управлять сложностью системы')];	
}
{
  let t = clear_text('Поведение системы при ООП описывается в терминах');
	answers[t] = [clear_text('обмена сообщениями между объектами')];	
}
{
  let t = clear_text('Инкапсуляция (принцип «черного ящика») позволяет');
	answers[t] = [clear_text('рассматривать структуру каждой подсистемы независимо от других подсистем')];	
}
{
  let t = clear_text('Единственный эффективный подход к решению проблемы сложности при разработке системы, который выработало человечество за всю свою историю, известен под названиями');
	answers[t] = [clear_text('объектная декомпозиция'),clear_text('иерархическая декомпозиция'),clear_text('«разделяй и властвуй» (divide et imperd)')];	
}
{
  let t = clear_text('CASE -технология охватывает');
	answers[t] = [clear_text('большинство процессов жизненного цикла ПО')];	
}
{
  let t = clear_text('Понятие «правильная» по отношению к декомпозиции означает следующее');
	answers[t] = [clear_text('связность отдельных частей внутри каждой подсистемы должна быть максимальной'),clear_text('количество связей между отдельными подсистемами должно быть минимальным')];	
}
{
  let t = clear_text('Абстрагирование — это выделение наиболее важных, существенных характеристик ________, которые отличают его от всех других видов объектов, и игнорирование менее важных или незначительных деталей');
	answers[t] = [clear_text('некоторого объекта')];	
}
{
  let t = clear_text('Обобщение (generalization) — связь «тип-подтип» реализует механизм наследования (inheritance). Она позволяет одному классу наследовать');
	answers[t] = [clear_text('все атрибуты, операции и связи другого')];	
}
{
  let t = clear_text('Атрибут — поименованное свойство класса, определяющее _________________,которые могут принимать экземпляры данного свойства');
	answers[t] = [clear_text('диапазон допустимых значений')];	
}
{
  let t = clear_text('Атрибут — это поименованное ________ класса');
	answers[t] = [clear_text('свойство ')];	
}
{
  let t = clear_text('Существуют четыре возможных семантики для агрегации');
	answers[t] = [clear_text('«Обладает»'),clear_text('«Участник»'),clear_text('«Безраздельно обладает»'),clear_text('«Включает»')];	
}
{
  let t = clear_text('Язык UML обеспечивает ограниченную поддержку агрегации. Сильная форма агрегации является в UML');
	answers[t] = [clear_text('композицией')];	
}
{
  let t = clear_text('Зависимость (dependency) — связь между двумя ____________, при которой изменения в спецификации одного элемента могут повлечь за собой изменения в другом элементе');
	answers[t] = [clear_text('элементами модели')];	
}
{
  let t = clear_text('Компонент представляет собой физическую реализацию проектной абстракции и может быть');
	answers[t] = [clear_text('компонентом исходного кода'),clear_text('исполняемым компонентом'),clear_text('компонентом времени выполнения (run time)')];	
}
{
  let t = clear_text('Любой объект обладает');
	answers[t] = [clear_text('поведением (behavior)'),clear_text('состоянием (state)'),clear_text('индивидуальностью (identity)')];	
}
{
  let t = clear_text('Язык UML обеспечивает ограниченную поддержку агрегации. Слабая форма агрегации в UML просто называется ________ ');
	answers[t] = [clear_text('агрегацией')];	
}
{
  let t = clear_text('К основным понятиям объектно-ориентированного подхода (элементам объектной модели) относятся:');
	answers[t] = [clear_text('операция'),clear_text('связи'),clear_text('полиморфизм (интерфейс)'),clear_text('компонент'),clear_text('класс'),clear_text('объект'),clear_text('атрибут')];	
}
{
  let t = clear_text('В широком смысле обязанности класса делятся на две категории');
	answers[t] = [clear_text('Знание (определяется атрибутами класса)'),clear_text('Действие (определяется операциями класса)')];	
}
{
  let t = clear_text('Существуют четыре различных типа операций');
	answers[t] = [clear_text('Операции управления (manager operations)'),clear_text('Операции доступа (access operations)'),clear_text('Операции реализации (implementor operations)'),clear_text('Вспомогательные операции (helper operations)')];	
}
{
  let t = clear_text('Агрегация (aggregation) представляет собой форму ассоциации — более сильный тип связи между целым __________ и его частями');
	answers[t] = [clear_text('объектом')];	
}
{
  let t = clear_text('Класс — это множество объектов, связанных общностью');
	answers[t] = [clear_text('семантики'),clear_text('связей'),clear_text('поведения'),clear_text('свойств')];	
}
{
  let t = clear_text('К основным типам связей между элементами объектной модели относятся');
	answers[t] = [clear_text('обобщения'),clear_text('зависимости'),clear_text('ассоциации')];	
}
{
  let t = clear_text('Агрегация типа «Обладает» поддерживает свойства');
	answers[t] = [clear_text('зависимость по существованию'),clear_text('транзитивность'),clear_text('асимметричность')];	
}
{
  let t = clear_text('Операции реализуют ___________ (иначе говоря, реализуют обязанности класса — responsibilities).');
	answers[t] = [clear_text('связанное с классом поведение')];	
}
{
  let t = clear_text('Агрегация типа «Безраздельно обладает» устанавливает следующее');
	answers[t] = [clear_text('агрегация транзитивна'),clear_text('агрегация асимметрична (нерефлексивна)'),clear_text('агрегация стационарна'),clear_text('между компонентными объектами и их составными объектами установлено отношение зависимости по существованию')];	
}
{
  let t = clear_text('Мощность (multiplicity) показывает, как много объектов участвует в связи. Мощность — это число ______ одного класса, связанных с одним объектом другого класса');
	answers[t] = [clear_text('объектов')];	
}
{
  let t = clear_text('Агрегация типа «Участник» обладает');
	answers[t] = [clear_text('свойством целенаправленного группирования независимых объектов')];	
}
{
  let t = clear_text('Полиморфизм — это способность скрывать множество __________________ под единственным общим интерфейсом');
	answers[t] = [clear_text('различных реализаций')];	
}
{
  let t = clear_text('Компонент — относительно независимая и _______ часть системы, выполняющая четко определенную функцию в контексте заданной архитектуры');
	answers[t] = [clear_text('замещаемая')];	
}
{
  let t = clear_text('Поведение объекта представляется с помощью');
	answers[t] = [clear_text('операций, которые может выполнять объект'),clear_text('набора сообщений, воспринимаемых объектом')];	
}
{
  let t = clear_text('Агрегация типа «Включает» поддерживает свойства');
	answers[t] = [clear_text('транзитивность'),clear_text('асимметричность')];	
}
{
  let t = clear_text('Графические (визуальные) модели представляют собой средства для');
	answers[t] = [clear_text('документирования архитектуры системы'),clear_text('визуализации архитектуры системы'),clear_text('проектирования архитектуры системы'),clear_text('описания архитектуры системы')];	
}
{
  let t = clear_text('М есть модель системы S, если М может быть использована для');
	answers[t] = [clear_text('получения ответов на вопросы относительно S с точностью А')];	
}
{
  let t = clear_text('Состав моделей, используемых в каждом конкретном проекте, и степень их детальности в общем случае (как для структурного, так и для объектно-ориентированного подхода) зависят от следующих факторов');
	answers[t] = [clear_text('знаний и навыков участников проекта'),clear_text('необходимой полноты ее описания'),clear_text('сложности проектируемой системы'),clear_text('времени, отведенного на проектирование')];	
}
{
  let t = clear_text('Под моделью ПО в общем случае понимается');
	answers[t] = [clear_text('описание ПО на определенном уровне абстракции'),clear_text('формализованное описание системы ПО')];	
}
{
  let t = clear_text('К моделям деятельности организации (или модели бизнес-процессов) относят');
	answers[t] = [clear_text('модели «AS-TO-BE» («как должно быть»)'),clear_text('модели «AS-IS» («как есть»)')];	
}
{
  let t = clear_text('Архитектурно значимый элемент — это элемент, имеющий значительное влияние на');
	answers[t] = [clear_text('структуру системы'),clear_text('возможность развития системы'),clear_text('производительность системы'),clear_text('надежность системы')];	
}
{
  let t = clear_text('Под термином «моделирование» понимается процесс создания формализованного описания системы в виде');
	answers[t] = [clear_text('совокупности моделей')];	
}

main();