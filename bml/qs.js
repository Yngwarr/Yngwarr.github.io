{
let ans = { "понятиебдсубд":`БД- совокупность взаимосвязанных , хранящихся вместе данных при наличии такой минимальной зависимости, которая допускает их совместное использование для одного или нескольких приложений оптимальным образом; данные запоминаются таким образом, чтобы они были независимы от программ. Способ хранения (структурирование) должен обеспечивать возможность обновления, поиска данных.
СУБД – средства централизованного управления БД как ресурсом в интересах пользователей и представляется набором программных средств, предназначенных ля создания общей БД для всего множества приложений, поддержание ее в рабочем состоянии, предоставление всех допустимых средств для работы и обеспечение эффективного доступа к данным в рамках полномочий пользователя.`,
"эволюцияметодов":
`Исторически можно выделить 5 этапов эволюции методов хранения данных. Этап №1 – автоматизированная обработка данных. Впервые автоматизированная обработка информации появилась приблизительно в 1800 году, когда Джеквард Лум начал производить раскрой ткани по образцам, представленным перфокартами. Используется в механических пианино. В 1890 г. Холлерит использовал технологию перфокарт для выполнения переписи населения Соединенных Штатов. Его система содержала запись на перфокарте для каждой семьи. Машины сводили подсчеты в таблицы по жилым кварталам, территориальным и административным округам и штатам. Бизнес Холлерита в конце концов привел к возникновению компании International Business Machines для производства оборудования, для записи данных на карты, сортировки и составления таблиц. К 1955 году у многих компаний имелись целые этажи, предназначенные для хранения перфокарт. На других этажах размещались шеренги перфораторов, сортировщиков и табуляторов. Эти машины программировались путем перемонтирования управляющих панелей, которые управляли некоторыми регистрами-накопителями и выборочно воспроизводили карты на других картах или на бумаге. 
Этап №2 – Ранние файловые системы(1955-1970). Файлы организованы простым последовательным способом. 
1.	Физическая структура данных такая же как и логическая структура файла. 
2.	Типовое ПО выполняет только операции ввода-вывода. 
3.	Полностью отсутствует независимость данных. Если менялась организация данных, требовалось модифицировать программу. 
4.	Высокая степень избыточности в файлах данных. Для того, чтобы обновить файл, требовалось записать новый файл; при этом сохранялся старый файл и, возможно, более ранняя версия. 
5.	Для облегчения программирования (сортировка, анализ, обработка данных) - первые специализированные языки: COBOL, RPG. 
6.	Одни и те же данные редко использовались для нескольких приложений. 
Этап №3 – развитые файловые системы . Физические данные представлены наборами данных (НД) с последовательной, индексно-последовательной и прямой организацией. В последовательном наборе данных все записи организованы строго последовательным способом; в наборе данных с прямой организацией возможен непосредственный доступ к любой записи по ее ключу; в индексно-последовательном наборе данных существует многоуровневая система индексов, позволяющая прямым образом определить дорожку диска, на которой расположена требуемая запись для ее последующего последовательного поиска. 
1.	Возможен как последовательный, так и произвольный доступ к записям (но не к полям записей). 
2.	Логическая и физическая структуры файлов различаются между собой, но связь между ними достаточно простая. 
3.	Остается значительная избыточность данных. 
4.	Сохраняется тенденция разрабатывать и оптимизировать данные в основном для одного приложения. 
5.	Типовым программным обеспечением (ПО) обработки данных являются методы доступа, а не методы управления данными. Операционные системы обеспечивали абстракцию файла для хранения этих записей, язык управления заданиями для выполнения заданий и планировщик заданий для управления потоком работ. 
Этап №4 – ранние СУБД(1965-1980). 
Простые индексно-последовательные организации записей развились в более мощные модели записей, ориентированной на наборы - иерархические модели данных. Иерархическая модель обладает существенным недостатком. Избыточное хранение данных не только дорого стоит, но также и порождает проблемы обновлений. Следующая по уровню развития модель - сетевая модель частично решает эти проблемы. Каждая запись хранится в одном экземпляре и связывается с набором других записей посредством связи. В процессе работы могут появляться как новые записи, так и связи. Управление ассоциативным доступом и обработкой, ориентированной на наборы, имело систему навигации, напоминающую модель страниц и ссылок нынешнего Internet.
1. Различные логические данные могут быть получены из одних и тех же физических данных;
2. Доступ к одним и тем же данным может осуществляться по различным путям, отвечающим этим приложениям;
3. Элементы данных являются общими для разных приложений;
4. ПО содержит средства уменьшения избыточности данных;
5. Уменьшение избыточности содействует повышению согласованности (целостности) данных.
6. База данных содержит не только данные, но и план, или модель данных. При создании БД разработчик описывает ее логическую структуру и способы видения БД пользователем. Такие описания базы данных называются моделью данных, схемой или концептуальной схемой. Модель определяет единицы данных, а также специфицируют связи каждой единицы данных с другими единицами данных. Например, число может появиться и в файле и в базе данных, но в файле это просто обезличенное число, а в базе данных число выполняет роль, назначенную для него моделью данных. Это может быть цена, номер заказа, индексом продукта и т.д.
7. СУБД позволяет различать и поддерживать два независимых взгляда на базу данных, воплощенных соответственно в "логической" и "физической" независимости данных. Логическая независимость данных означает, что общая структура данных может быть изменена без изменения прикладных программ. Под физической независимостью данных понимается способность СУБД предоставлять некоторую свободу модификации способов организации базы данных в среде хранения (например, с целью повышения эффективности БД), не вызывая необходимости внесения соответствующих изменений в логическое представление и не затрагивая созданных прикладных программ, использующих БД.
Этап № 5–Современные СУБД. Несмотря на успех сетевой модели данных, чувствовалось, что навигационный программный интерфейс был интерфейсом слишком низкого уровня. В статье Э.Ф. Кодда 1970 года была обрисована реляционная модель, которая стала альтернативой низкоуровневому навигационному интерфейсу. Идея реляционной модели состоит в том, чтобы единообразно представлять и сущности, и связи посредством плоских таблиц.`,
"недостаткифайловыхсистем":
`Для ранних файловых систем: Полностью отсутствует независимость данных. Если менялась организация данных, требовалось модифицировать программу. Высокая степень избыточности в файлах данных. Для того, чтобы обновить файл, требовалось записать новый файл; при этом сохранялся старый файл и, возможно, более ранняя версия. Одни и те же данные редко использовались для нескольких приложений. 
Для развитых файловых систем: Остается значительная избыточность данных. Сохраняется тенденция разрабатывать и оптимизировать данные в основном для одного приложения. Сложна реализация нестандартных запросов.`,
"характеристикиэтаповразвития":"см. эволюцияметодов",
"свойстваразвитыхсубд":
`Различные логические данные могут быть получены из одних и тех же физических данных.
Элементы данных являются общими для разных приложений.
Средства уменьшения избыточности данных -> повышение согласованности данных
Подержание трехуровневой архитектуры базы данных.
Модель данных.
Логическая и физическая независибость данных.`,
"концептуальнаясхема":
`Концептуальная модель - это отражение предметной области, для которой разрабатывается база данных. Не вдаваясь в теорию, отметим, что это некая диаграмма с принятыми обозначениями элементов. Так, все объекты, обозначающие вещи, обозначаются в виде прямоугольника. Атрибуты, характеризующие объект - в виде овала, а связи между объектами - ромбами. Мощность связи обозначаются стрелками (в направлении, где мощность равна многим - двойная стрелка, а со стороны, где она равна единице - одинарная).`,
"независимостьданных":
`Логическая независимость предполагает возможность изменения одного приложения без корректировки других приложений, работающих с этой же базой данных. Физическая независимость предполагает возможность переноса хранимой информации с одних носителей на другие при сохранении работоспособности всех приложений, работающих с данной базой данных.`,
"развитиеязыков":
`Для работы с базами данных используются специальные языки, в целом называемые языками баз данных. В ранних СУБД поддерживалось несколько специализированных по своим функциям языков. Чаще всего выделялись два языка - язык определения схемы БД (SDL - Schema Definition Language) и язык манипулирования данными (DML - Data Manipulation Language). SDL служил главным образом для определения логической структуры БД. DML содержал набор операторов манипулирования данными, т.е. операторов, позволяющих заносить данные в БД, удалять, модифицировать или выбирать существующие данные.
В современных СУБД поддерживается единый интегрированный язык, содержащий все необходимые средства для работы с БД, начиная от ее создания, и обеспечивающий базовый пользовательский интерфейс с базами данных. Стандартным языком наиболее распространенных в настоящее время реляционных СУБД является язык SQL (Structured Query Language) - Язык SQL сочетает средства SDL и DML.`,
"логическаяцелостность":
`Поддержка логической целостности (непротиворечивости) базы данных. В развитых СУБД ограничения целостности базы данных объявляются в схеме базы данных и их проверка осуществляется при каждом обновлении объектов данных или связей между ними.
Язык SQL содержит специальные средства определения ограничений целостности БД. (Для большинства СУБД для PC-машин ограничения целостности поддерживаются только на стадии ввода).
Помимо ввода некорректных данных и неправомерными действиями процедур модификации данных, нарушение логической целостности может быть вызвано следствием несвоевременного прерывания выполнения таких процедур при обработке запроса, выданного другим пользователем, либо внешними причинами (пример некорректного переноса данных с одного счета на другой). Для исключения таких ситуаций предусматривается механизм транзакций.`,
"функциисубд":
`1.	непосредственное управление данными во внешней памяти. 
2.	Управление буферами оперативной памяти.
3.	Поддержка языков БД
4.	Поддержка логической целостности БД.
5.	Управление транзакциями
6.	Журнализация-средство архивирования и восстановления данных
7.	Совместное использование БД
8.	Средства защиты данных(собственные форматы хранения данных, использование сырого дискового пространства–секторов, а не ф.с.), управление безопасностью и секретностью данных.
9.	Параллельная обработка БД`,
"сбой": `Мягкий сбой– потеря одной или более транзакций. Жесткий сбой– потеря информации во внешней памяти.
Мягкий сбой системы (аварийный отказ программного обеспечения). Мягкий сбой характеризуется утратой оперативной памяти системы. При этом поражаются все выполняющиеся в момент сбоя транзакции, теряется содержимое всех буферов базы данных. Данные, хранящиеся на диске, остаются неповрежденными. Мягкий сбой может произойти, например, в результате аварийного отключения электрического питания или в результате неустранимого сбоя процессора. 
Жесткий сбой системы (аварийный отказ аппаратуры). Жесткий сбой характеризуется повреждением внешних носителей памяти. Жесткий сбой может произойти, например, в результате поломки головок дисковых накопителей.`,
"журнализация":
`Журнал – это особая часть БД, недоступная пользователям СУБД, с которой поступают данные об изменениях основной части БД. Всегда используется стратегия упреждающей записи в журнал (протокол Write Ahead Log ).  Запись об изменениях любого объекта БД сначала попадает во внешнюю память журнала, а потом измененный объект попадает во внешнюю память БД. Т.о. во внешней памяти могут находиться объекты, модифицированные в течении успешной транзакции, так и объекты, модификация которых не была завершена к моменту мягкого сбоя. Для приведения БД в согласованное состояние производится откат незавершенной транзакции. При жестком сбое используется архивная копия БД (сохраненная до начала записи в журнал) и сам журнал. Берется архивная копия, и по журналу повторяются все транзакции.`,
"классификациябд":
`1.	по степени универсальности
•	системы общего назначения
•	специализированные
2.	по характеру использования
•	однопользовательские (локальные СУБД на локальной Машине)
•	многопользовательские, являющиеся компонентами вычислительной сети и обеспечивающие распределенную обработку данных
3.	Многопользовательские различаются по архитектуре
•	С многотерминальной архитектурой (host-терминалы)
•	С файловым сервером
•	Клиент-сервер
4.	по организации
•	СУБД, поддерживающие централизованные БД
•	СУБД, поддерживающие распределенные БД
5.	по степени интеграции железа и ПО
•	многоплатформные
•	ориентированные на определенную архитектуру или организацию оперативной памяти
6.	по назначению СУБД
•	OLTP (online transaction processing)
•	OLAP (online analytical processing)
7.	по используемой модели данных
•	дореляционные (иерархическая, сетевая модель)
•	реляционная модель
•	постреляционные модели(объектно-ориентированные, объектно-реляционные)
•	специализированные модели (временные, пространственные)
8.	по уровню обработки данных 
•	проблемно-ориентированные СУБД
•	процедурно –ориентированные СУБД`,
"многотерминальнаяархитектура":
`Достоинства: отсутствует проблема организации множественного доступа к БД; проще решается проблема удаленности рабочих мест от сервера, т.к. по линиям связи передаются только измененные фрагменты экрана и данные пользователя.
Недостатки: высокая стоимость администрирования и сопровождения терминальных систем; производительность с ростом числа пользовательских мест падает.`,
"архитектурафайловогосервера":
`Приложение использует общие файлы с файлового сервера. Используется метод разделения файлов, представляемых сетевой ФС. Достоинство: возможность быстро и относительно недорого запустить однопользовательское приложение в однопользовательском режиме. Недостатки: вся обработка идет на локальных машинах, а данные хранятся на сервере, значит неизбежен высокий трафик в сети; обеспечение целостности данных возлагается на прикладную программу, значит любая ошибка в ней ведет к несогласованности данных; при случайном аппаратном сбое сервер не может проверить корректность хранимых данных, т.к. ничего не знает о их структуре; высокая стоимость администрирования; отсутствие аппарата транзакций.`,
"архитектураклиентсервер":
`Достоинства: архетиктура позволяет организовать распределенную обработку данных, выполняя первичную и конечную обработку на машине клиента, а компьютер-сервер выполняет наиболее трудоемкие функции по хранению, администрированию, защите данных, управлением эффективным поиском данных.`,
"oltp":
`Основная функция– выполнение большого числа коротких транзакций. Характеризуется большим числом пользователей, относительно короткими запросами, малым временем отклика, небольшое число операторов SQL в транзакции, использование в запросах небольшого числа таблиц. Иногда виды запросов к базе данных ограничиваются некоторым набором.`,
"olap":
`Виды подобных систем: системы принятия решений (decision support system ) , хранилища данных (data warehouse ), системы интеллектуального анализа данных (data mining ). 
Все OLAP системы предназначены для нахождения зависимостей между данными. OLAP приложения оперируют большими  массивами данных. Добавление данных производится относительно редко, данные никогда не удаляются, перед загрузкой данные проходят процедуру очистки, большое число пользователей, большие размеры таблиц и строк таблиц, скорость выполнения запросов важна , но некритична.
OLAP-технология представляет для анализа данные в виде многомерных (и, следовательно, нереляционных) наборов данных, называемых многомерными кубами (гиперкуб, метакуб, кубом фактов), оси которого содержат параметры, а ячейки - зависящие от них агрегатные данные
При том гиперкуб является концептуальной логической моделью организации данных, а не физической реализацией их хранения, поскольку храниться такие данные могут и в реляционных таблицах ("реляционные БД были, есть и будут наиболее подходящей технологией для хранения корпорационных данных" - E. Codd). 
По Кодду, многомерное концептуальное представление (multi-dimensional conceptual view) представляет собой множественную перспективу, состоящую из нескольких независимых измерений, вдоль которых могут быть проанализированы определенные совокупности данных. Одновременный анализ по нескольким измерениям определяется как многомерный анализ. Осями многомерной системы координат служат основные атрибуты анализируемого бизнес-процесса (то, по чему ведется анализ). Например, для продаж это могут быть тип товара, регион, тип покупателя. В качестве одного из измерений используется время. На пересечениях осей - измерений (dimensions) - находятся данные, количественно характеризующие процесс - меры (measures): суммы и иные агрегатные функции (min, max, avg, дисперсия, ср. отклонение и пр.). Каждое измерение включает направления консолидации данных, состоящие из серии последовательных уровней обобщения (уровней иерархии), где каждый вышестоящий уровень соответствует большей степени агрегации данных по соответствующему измерению (различные уровни их детализации). В этом случае становится возможным произвольный выбор желаемого уровня детализации информации по каждому из измерений.
171. Операции OLAP-технологии.
Аналитические OLAP-операции:
•	Сечение. При выполнении операции сечения формируется подмножество гиперкуба, в котором значение одного или более измерений фиксировано (значение параметров для фиксированного, например, месяца). 
•	Вращение (rolling). Операция вращения изменяет порядок представления измерений, обеспечивая представление метакуба в более удобной для восприятия форме. 
•	Консолидация (rolling up). Включает такие обобщающие операции, как простое суммирование значений (свертка) или расчет с использованием сложных вычислений, включающих другие связанные данные. Например, показателю для отдельных компаний могут быть просто просуммированы с целью получения показателей для каждого города, а показатели для городов могут быть "свернуты" до показателей по отдельным странам. 
•	Операция спуска (drill doun). Операция, обратная консолидации, которая включает отображение подробных сведений для рассматриваемых консолидированных данных. 
•	Разбиение с поворотом (slicing and dicing). Позволяет получить представление данных с разных точек зрения. Например, один срез данных о доходах может содержать все сведения о доходах от продаж товаров указанного типа по каждому городу. Другой срез может представлять данные о доходах отдельной компании в каждом из городов.`,
"многопользовательскаясубд":
`Терминальная архитектура: терминал организует взаимодействие с пользователем; ПО сервера производит обработку данных, СУБД сервера обрабатывает запросы к БД, операционная система сервера хранит файлы БД.
Архитектура файлового сервера: ОС сервера хранит файлы БД; клиент ( прикладная программа на FoxPro, например )– организует взаимодействие с пользователем и обрабатывает данные и запросы к БД.
Серверная архитектура; серверное ПО СУБД обрабатывает запросы к БД, сетевая ОС хранит файлы БД, клиент (прикладная программа) взаимодействует с пользователем и обрабатывает данные, клиентское ПО СУБД взаимодействует с серверной частью СУБД на уровне запрос-ответ.`,
"распределённаясубд":
`Распределенная БД предполагает хранение и выполнение функций управления данными в нескольких узлах, а также передачу данных между узлами  в процессе выполнения запроса. Разбиение данных в распределенных СУБД выполняется прозрачно для пользователя и достигается путем хранения на различных серверах различных таблиц данных или их частей. Часто распределенная БД  управляется локальными СУБД , при этом СУБД в узлах не обязаны быть одинаковыми.`,
"типоваяорганизациясубд":
`Ядро СУБД: менеджер данных, менеджер транзакций, менеджер журнала, менеджер буферов, интерфейс ядра. С интерфейсом ядра взаимодействует SQL-компилятор и набор программных утилит(процедуры, которые накладно выполнять посредством SQL), компилятор , в свою очередь, получает информацию от интерпретатора и оптимизатора.
Результат работы компилятора– исполняемый файл или интерпретируемая программа`,
"процедурноориентированныесубд":
`К процедурно-ориентированным причисляют СУБД для ПК: Dbase, Fox Base, Fox Pro. Имеется специальный набор операторов языка и набор функций, посредством которых программно строится алгоритм обработки данных.
Проблемно-ориентированные –SQL- ориентированные СУБД. Сервер выбирает оптимальный способ выполнения запроса.`,
"восстановлениеданных": ":(",
"конвейерныйпараллелизм":
`Реляционная модель включает набор операций, замкнутых по композиции, т.е. каждая операция получает отношение на входе и выдает тоже отношение. Поэтому реляционные операции предоставляют возможности конвейерного параллелизма, когда результаты одной операции могут быть использованы в следующей операции, не дожидаясь завершения предыдущей операции. Помимо конвейерного параллелизма возможен вариант разнесенного параллелизма, когда операция разбивается на несколько частей, выполняемых параллельно.`,
"этапыобработкизапроса":
`Запрос проходит лексический и синтаксический анализ. Получается внутреннее представление запроса. Это представление проходит логическую оптимизацию, подбирается оптимальный план выполнения. Подготавливается выполняемый план. Получается выполняемое представление запроса. План выполняется.`,
"уровнидоступа":
`1-не предполагается никаких средств для организации БД. Данные хранятся в файлах ФС. Обработка данных программируется на обычном языке программирования посредством системных вызовов Read, write, open.
2- использование интерфейса CLI(call level interface) . Библиотечные функции языка высокого уровня реализуют доступ, поиск, методы индексации и т.д. ODBC(Open Data Base Connectivity )
3- встроенный SQL. На этапе работы препроцессора SQL- описания заменяются вызовами функций библиотек CLI-интерфейса, после чего программа линкуется и выполняется.
4- язык 4-ого поколения. Процедурный язык с интегрированным SQL-ом, средствами построения экранных форм, отчетов, меню и т.д.
5- Доступ из среды Internet
6- без программирования.`,
"описаниеглавныхпеременных":
`В объявлении главных переменных в ESQL/C им предшествует знак $ или описание производится внутри блока: Exec SQL begin declare section . . . . . Exec SQL end declare section
Тип и класс хранения главных переменных определяется аналогично С (automatic, static, external). Как и в С возможны массивы (одно-, двумерные), структуры и указатели главных переменных. Инициализация переменных также аналогична С.`,
"обработкаошибоквc":
`Сервер базы данных всегда возвращает код ошибки и некоторую другую информацию о выполнении операции в структуре данных, называемой областью связи SQL (SQL Communication Area - sqlca). Поле sqlcode структуры sqlca содержит основной код возврата.
sqlca.sqlcode = 0 - успешное выполнение; sqlca.sqlcode < 0 - код ошибки (детализированное значение кода ошибки может содержаться во втором элементе поля sqlerrd;  0< sqlca.sqlcode < 100 - в зависимости от описания;sqlca.sqlcode = SQLFOUND - больше не найдено строк (#define SQLFOUND 100).`,
"nullвc":
`Поскольку в языке С нет возможности убедиться, имеет ли элемент таблицы какое-либо значение, ESQL/C делает это для своих главных переменных., называемых переменными-индикаторами. Переменная-индикатор является дополнительной переменной, ассоциированной с главной переменной, в которую могут поступать NULL-значения. Когда сервер БД помещает данные в главную переменную, он также устанавливает специальное значение в переменную-индикатор, которое показывает, не являются ли эти данные NULL-значением. При описании переменной-индикатора он отделяется от главной переменной знаком ":" , "$" или словом INDICATOR, а при использовании отделяется знаком ":". При выборе оператором Select NULL-значения переменная-индикатор (если она используется) получает значение -1. В случае нормального возврата переменной индикатор равен 0. В случае, если индикатор не используется, то результат зависит от режима генерации программы.`,
"курсорвc":
`Последовательность программных операций при работе с курсором:
Программа объявляет курсор и ассоциированный с ним оператор Select. Операция приводит к выделению памяти для хранения курсора (оператор Declare) 
Программа открывает курсор. Это приводит к началу выполнения ассоциированного оператора Select, а также к распознаванию наличия ошибок (оператор Open) 
Программа считывает строку данных в главные переменные и обрабатывает их (оператор Fetch) 
Программа закрывает курсор после прочтения последней строки (оператор Close) 
Множество строк, возвращаемое предложением Select, носит название активного множества. 
Курсор может находиться в одном из двух состояний: открытом и закрытом. Когда курсор открыт, он связан с активным множеством и может указывать либо на текущую строку, либо между строк, либо перед первой строкой, либо после последней строки. Если курсор находится в закрытом состоянии, то он не связан с активным множеством, хотя и остается связанным с предложением Select.`,
"динамикавc":
`Последовательность выполнения приведенных выше операторов:
Символьная строка, содержащая оператор Select помещается в программную переменную (select.). Она содержит N заполнителей, отмеченных знаком "?". 
Оператор Prepare преобразует символьную строку в структуру данных, связанную с именем orders. Объявляется курсор cu_orders и связывается с именем подготовленного оператора. 
При открытии курсора начинается выполнение подготовленного оператора. Спецификация using в операторе Open представляет имена N главных переменных, содержимое которых заменяет знаки вопроса в выполняемом операторе. Спецификатор into оператора Fetch специфицирует главные переменные, которые должны принимать значения столбцов строки, выбранной по курсору.`,
"idf0":
`Система IDF0 представляет совокупность взаимодействующих работ, связи между работами, определенный технологический процесс, либо взаимосвязь внутри организации. Все это собирается в группу диаграмм, представляющую автоматизируемый объект. Работа– поименованный процесс, функция или задача, которая происходит в течение определенного времени и имеет распознаваемый результат.`,
"видысвязейвidf0":
`Существует 5 видов связей.
1.	связь по входу. Выход вышестоящей работы направлен на вход нижестоящей.
2.	Связь по управлению.
3.	Обратная связь по входу.
4.	Обратная связь по управлению
5.	Связь выход-механизм`,
"диаграммапотоковданных":
`Описывает движение документов и обработки информации, дополняет IDF0 . Диаграммы дополнены хранилищами данных.`,
"этапыпроектированиябд":
`1.	инфологическое проектирование: Адекватная оценка предметной области и информационных потребностей пользователей. Получение семантических(смысловых) моделей
2.	Логическое проектирование: отображение предметной области в абстрактные объекты модели данных, чтобы отображение не противоречило семантике предметной области.
3.	Физическое проектирование: обеспечение эффективности выполнения запросов к БД, принимая во внимание выбранную СУБД.`,
"инфологическоепроектирование": "Строим ER(Entity Relationship) модель. Определяем сущности, связи , атрибуты.",
"логическоепроектирование": "Проблема логического проектирования реляционной БД состоит в обоснованном принятии решения о том, из каких отношений должна состоять БД, какие атрибуты должны быть у этих отношений. Аппарат нормализации. Основная цель- сокращение избыточности хранимых данных и устранение возможных потенциальных аномалий работы с БД.",
"физическоепроектирование": "Выбор рациональной структуры хранения данных и методов доступа к ним.",
"сущность": `Сущность– реальный или представляемый объект предметной области, информация о котором должна сохраняться и быть доступна. Понятие тип сущности относится к набору однородных предметов, событий, личностей, выступающих как единое целое. Экземпляр сущности относится к конкретной вещи в наборе.
Абсолютное различие между  типами сущностей и атрибутами отсутствует. Атрибут является таковым только в связи с типом сущности. Множество из одного или нескольких атрибутов, значения которых однозначно определяет каждый экземпляр сущности, называется идентификатором. Каждая сущность обязана иметь хотя бы один идентификатор. Если их несколько, то выбирается привилегированный.`,
"способыпредставлениясущности": "Набором атрибутов, выполняющих роль идентификаторов. Графически(атрибуты в столбик), в текстовом представлении (атрибуты через запятую в скобочках), в табличном виде(колонка-атрибут).",
"атрибут": "Атрибут– поименованная характеристика сущности, определяющая его свойства и принимающая значения из некоторого множества значений. Атрибуты бывают : описательные (характеристика, внутренне присущая каждому экземпляру сущности), указывающие (используются для присвоения имени или обозначения экземпляра сущности), вспомогательные (связь экземпляра одной сущности с экземпляром другого).",
"правилаатрибутов":
`1.	Один экземпляр сущности имеет одно единственное значение каждого атрибута в любое данное время. 
2.	Атрибут не должен содержать никакой внутренней структуры. 
3.	 Когда сущность имеет составной идентификатор, каждый атрибут, не являющийся частью идентификатора, представляет характеристику всей сущности, а не ее части.
4.	Атрибут, не являющейся частью идентификатора , представляет характеристику экземпляра, указанного идентификатором, а не характеристику некоторого другого атрибута(неидентификатора).
Проявления правил в табличном представлении:
Первое правило: существует только один элемент данных для каждой строки и столбца. невозможно появление незаполненных ячеек и ячеек с группой значений. Второе: ячейка не может произвольно делиться на части.`,
"связь": "Связь– поименованная, графически изображаемая ассоциация , устанавливающая собой абстракцию набора отношений, которые семантически возникают между различными видами предметов в реальном мире. Дальше все и так понятно.",
"формализациясвязи":
`Описание связи должно обеспечивать 1. Идентификатор связи, формулировку имен связи с точки зрения каждой участвующей сущности, вид связи(множественность, условность), формулировку того, как связь была формализована. Вспомогательные атрибуты. Для формализации связи «один к одному» вспомогательные атрибуты могут быть добавлены к любой сущности (но не к обоим).
«Один ко многом»– к сущности на стороне «многого», «многие ко многим»– создание отдельной ассоциативной сущности, которая содержит ссылки на идентификаторы каждого из участвующих экземпляров.`,
"стержневаясущность": "Стержневая – независимая сущность;",
"ассоциативнаясущность": "ассоциативная сущность– формализующая связь «многие ко многим» или связи вида «один к одному » между экземплярами сущности(могут рассматриваться как полноправные сущности);",
"характеристческаясущность": "характеристическая(уточняет некоторой другой сущности)– связь «многие к одной» или «один к одному»;",
"обозначающаясущность": "обозначающая сущность – отличается от характеристики тое, что не зависит от обозначаемой сущности.",
"каскадноеудаление": "Вариант решения задачи удаления экземпляра целевой сущности.",
"композициясвязей": "Связи могут быть логическими следствиями других связей. Говорят, что такие связи образуют композицию связей. Такая связь не может быть формализована во вспомогательных атрибутах.",
"подтип": "Сущность, на основе которой строятся подтипы – супертип. Сущность может быть расщеплена на два или более взаимно исключающих подтипа, каждый из которых включает общие атрибуты и(или) связи. В подтипах могут определяться собственные атрибуты и (или) связи.",
"отношение":
`Бинарное отношение R(A,B) –множество упорядоченных пар (a,b), где а из А, b из B.
Рефлексивность хRx для всех x из A, иррефлексивность xRx для всех x не из A, симметричность хRy -> yRx, асcимметричность xRy или yRx, антисимметричность xRy и yRx -> х=у, транзитивность xRy и yRz -> xRz`,
"классыотношений":
"Эквивалентность – транзитивность, рефлексивность, симметричность. Толерантность– рефлексивность и симметричность. Квазипорядок– транзитивность и рефлексивность. Строгий порядок – антирефлексивность, антисимметричность, транзитивность. Частичный порядок– рефлексивность, антисимметричность, транзитивность.",
"модельданных": "Моделью данных называется формализованное описание структур единиц информации и операций над ними.",
"иерархическаямодель":
`ИМ представляется связанным графом типа дерева, вершины которых располагаются на разных иерархических уровнях. Иерархическая БД состоит из упорядоченного набора деревьев. Тип дерева в целом представляет собой иерархически организованный набор типов записей.
Организация иерархической древовидной структуры: все типы связей должны быть функциональными (1:1, 1:M, M:1); Дерево представляет собой неориентированный граф, не содержащий циклов. тип дерева состоит из одного "корневого" типа записи и упорядоченного набора из нуля или более типов поддеревьев (каждое из которых является некоторым типом дерева). В дереве каждый узел i-уровня связан только с одним родительским узлом (i-1)-уровня (любой сын может иметь не более родного отца, а любой отец - множество сынов); дуга дерева соответствует типу связи "исходный- порожденный"; доступ к каждому порожденному узлу выполняется через непосредственно исходный узел; все экземпляры данного типа потомка с общим экземпляром типа предка называются близнецами. Для БД определен полный порядок обхода - сверху-вниз, слева-направо; существует единственный линейный иерархический путь доступа к любому узлу, начиная с корня дерева. 
1. Операции манипулирования данными в иерархических системах ориентированы прежде всего на поиск информации сверху-вниз, т.е. по данному экземпляру сегмента-отца можно найти все экземпляры сегментов-сыновей. Обратный поиск затруднен, а часто и невозможен. Например, приведенный выше запрос работает чрезвычайно быстро, поскольку направление поиска совпадает со схемой иерархии. 
2. Дублирование данных на логическом уровне.
3. Для представления связи M:N необходимо дублирование деревьев.
4. В ИМ автоматически поддерживается целостность ссылок между предками и потомками по правилу: никакой потомок не может существовать без своего родителя. Целостность по ссылкам между записями, не входящими в одну иерархию, не поддерживается. Поэтому невозможно хранение в БД порожденного узла без соответствующего исходного. Аналогично, удаление исходного узла влечет удаление всех порожденных узлов (деревьев), связанных с ним.`,
"операторманипулированияданными":
`Найти указанное дерево БД (например, больницу ї40); Перейти от одного дерева к другому; Перейти от одной записи к другой внутри дерева (например, от палаты - к первому пациенту); Перейти от одной записи к другой в порядке обхода иерархии; Вставить новую запись в указанную позицию; Удалить текущую запись. 
Язык доступа к данным, который поддерживает IMS, позволяет обращаться к элементам напрямую, зная название и, возможно, дополнительное условие. 
Get Unique Сборник Where Ответственный_редактор = "Иванов"
While true do
Print Сборник.Название
Get next Сборник Where Ответственный_редактор = "Иванов"
End while
Выбрав один из сборников в предыдущем примере, можно спуститься "вниз" по иерархии (оператор Get next Within Parent позволяет перебрать все элементы-потомки, принадлежащие выбранному элементу) и, например, просмотреть одну из статей или несколько статей из выбранного сборника 
While true do
Print "Сборник", Сборник.Название
Get next Within Parent Статья
While true do
Print Статья.Название
Get next Within Parent Статья
End while
Get next Сборник Where Ответственный_редактор = "Иванов"
End while
68. характеристика операторов манипулирования данными в СМ
Найти конкретную запись в наборе однотипных записей (палату с указанным номером); Перейти от предка к первому потомку по некоторой связи (к первому врачу некоторой больницы); Перейти к следующему потомку в некоторой связи (от врача Сидорова к Иванову); Перейти от потомка к предку по некоторой связи (найти больницу врача Сидорова); Создать новую запись; Уничтожить запись; Модифицировать запись; Включить в связь; Исключить из связи; Переставить в другую связь и т.д.`,
"сетеваямодель":
`Цель разработчиков: создание модели, позволяющей описывать связи M:N и позволяющей уменьшить недостатки ИМ.
СМ данных базируется также на использовании представления данных в виде графа. C точки зрения теории графов СМ соответствует произвольный граф: в иерархических структурах запись-потомок должна иметь в точности одного предка; в сетевой структуре данных потомок может иметь любое число предков. Вершины графа используются для интерпретации типов объектов. Дуги графа используются для интерпретации типов связей между типами объектов. Такое изображение структуры БД называется диаграммой Бохмана.
Сетевая БД состоит из набора записей и набора связей между этими записями. Тип связи определяется для двух типов записей: предка и потомка. Экземпляр типа связи (в некоторой литературе набор) состоит из одного экземпляра типа записи предка и упорядоченного набора экземпляров типа записи потомка. Более строго набор - поименованная совокупность записей, в котором записи одного типа объявляются владельцами набора, в записи других типов - членами этого набора.
Внутренние особенности СМ:
1. Все типы связей должны быть функциональными (1:1, 1:M, M:1); В модели это внутреннее ограничение выражается утверждением: для данного типа связи L с типом записи предка P и типом записи потомка C (набора) должны выполняться следующие два условия: 
•	Каждый экземпляр типа P является предком только в одном экземпляре L; 
•	Каждый экземпляр C является потомком не более, чем в одном экземпляре L. 
2. Экземпляр записи может быть членом только одного экземпляра набора среди всех экземпляров набора одного типа (он может входить в состав двух и более экземпляров наборов, но разных типов).
3. Для представления связи M:N вводится дополнительный тип записи и две функциональные связи типа 1:M и M:1. При необходимости запись-связка может содержать дополнительную информацию.
4. СМ не позволяет непосредственно представлять данные, описывающие связи, которые имеют собственные описательные атрибуты. В этом случае так же вводится вспомогательный тип записи.
Ограничения на типы связей смотри двумя строчками выше. 
Ограничения на типы записей: 1. Тип записи потомка в связи 1 может быть типом записи предка в другом типе связи 2 (типа иерархия); 2. Данный тип записи Р может быть типом записи предка в любом числе типов связи, и может быть типом записи потомка в любом числе типов связей; 3. Может существовать любое число видов связей между предком и потомком; типы записей предка и потомка в одной связи могут быть потомком и предком в другой связи; предок и потомок типа связи могут совпадать (получается цикл- предшествующая вершина является также предыдущей или петля).`,
"домен":
"Домен– допустимое потенциальное множество значений данного типа. Домен определяется заданием некоторым базовым типом данных к которому относятся элементы домена и логическим выражением , которое применяется к каждому элементу типа данных. Если значение истинно, то элемент принадлежит домену, иначе– нет. Каждый домен описывает некоторый атрибут, который представляет собой поименованную характеристику некоторой сущности. Семантическая нагрузка понятия домена состоит в том, что данные сравнимы тогда и только тогда, когда они принадлежат одному домену.",
"отношениереляционноймоделиданных": "Пусть есть совокупность доменов. Набор значений из каждого домена по штуке называется кортежем. Множество всех кортежей– декартово произведение доменов. Отношение– подмножество кортежей из декартового произведения  доменов.",
"схема": "Схема отношения– поименованное множество пар < имя_атрибута, имя_домена>, либо множество атрибутов(когда атрибут несет информацию о домене). По числу атрибутов определяетс арность схемы отношения. Реляционная БД– конечное множество отношений ",
"ключ":
`Атрибут, значение которого идентифицирует картеж называется ключом отношения. В некоторых отношениях картеж идентифицируется конкатенацией нескольких атрибутов– составной ключ. Если отношение имеет несколько ключей, то один из них объявляется как первичный ключ. Для организации взаимосвязей между отношениями используется внешний ключ. Атрибут называется внешним ключом, если его значение однозначно характеризует сущности, представленные кортежами некоторого другого отношения, заданного своим первичным ключом.
105. Возможные подходы относительно удаления целевой сущности, на которую ссылается внешний ключ.
Каскадировать (всегда удалать), ограничивать (иногда разрешать, а иногда– нет), устанавливать неопределенное значение.
106. Возможные подходы относительно обновления первичного ключа целевой сущности, на которую ссылается внешний ключ.
Каскадировать, ограничивать, устанавливать.`,

"свойстваотношений":
`1 отсутствие кортежей– дубликатов
2. отсутствие упорядоченности кортежей
3. отсутствие упорядоченности атрибутов
4. атомарность атрибутов`,
"остутствиекортежейдубикатов":
`То свойство, что отношения не содержат кортежей-дубликатов, следует из определения отношения как множества кортежей. В классической теории множеств по определению каждое множество состоит из различных элементов. 
Свойство отсутствия упорядоченности кортежей отношения также является следствием определения отношения-экземпляра как множества кортежей. Отсутствие требования к поддержанию порядка на множестве кортежей отношения дает дополнительную гибкость СУБД при хранении баз данных во внешней памяти и при выполнении запросов к базе данных. Это не противоречит тому, что при формулировании запроса к БД, например, на языке SQL можно потребовать сортировки результирующей таблицы в соответствии со значениями некоторых столбцов. Такой результат, вообще говоря, не отношение, а некоторый упорядоченный список кортежей. 
Атрибуты отношений не упорядочены, поскольку по определению схема отношения есть множество пар {имя атрибута, имя домена}. Для ссылки на значение атрибута в кортеже отношения всегда используется имя атрибута. Это свойство теоретически позволяет, например, модифицировать схемы существующих отношений не только путем добавления новых атрибутов, но и путем удаления существующих атрибутов. Однако в большинстве существующих систем такая возможность не допускается, и хотя упорядоченность набора атрибутов отношения явно не требуется, часто в качестве неявного порядка атрибутов используется их порядок в линейной форме определения схемы отношения.`,
"реляционнаямодель":
`Состоит из трех частей. Структурная– единицей структурны данных является нормализованное н-арное отношение. Манипуляционная– два механизма манипулирования данными: реляционная алгебра и реляционное исчисление. Реляционная алгебра базируется на классической теории множеств и является процедурным языком. Реляционное исчисление строится на классическом аппарате исчисления предикатов 1-ого порядка и является непроцедурным языком. Целостная– два базовых требования целостности. А) требование целостности сущностей. Каждое отношение , выражающее сущность или объект реального мира кортежем, должно обладать первичным ключом. Б) требование целостности по ссылкам. Для каждого внешнего ключа должен существовать первичный ключ. Значит нужно запретить удаление кортежа, на который есть ссылки, или разрешить неопределенное значение внешнего ключа, или каскадно удалять все нафиг.`,
"реляционноеисчисление":
`Выражение реляционной алгебры и формула реляционного исчисления определяются над отношениями реляционной БД, и их результатом также является отношение реляционной алгебры. Язык манипулирования реляционной БД называется реляционно полным, если любой запрос, выражаемый одной формулой реляционной алгебры или одним выражением реляционного исчисления, может быть записан с помощью одного оператора языка. Механизмы реляционной алгебры и реляционного исчисления являются эквивалентными.
Операции объединения и пересечения, разности– бинарные операции, выполняемые над отношениями- синонимами. Отношения- синонимы– отношения одной арности, атрибутам первого отношения найдутся  атрибуты второго отношения, которые принадлежат той же области определения. Результатом операции объединения будет отношение той же арности, включающее все кортежи, входящие хотя бы в одно из отношений- операндов. Разность– множество кортежей из первого операнда, которые не участвуют в отношении второго операнда. Декартово произведение – кортежи увеличенной длины. Проекция– отбор компонентов кортежей (атрибутов) с последующим удалением дубликатов в результирующем множестве. Ограничение– кортежи предикаты, удовлетворяющие некоторым дополнительным ограничениям. Соединение двух бинарных отношений по заданным атрибутам– все кортежи обоих отношений, атрибуты которых находятся в третьем, заданном бинарном отношении. Операция эквисоединения– операция соединения с бинарной операцией равенства между атрибутами и удалением в результирующем множестве одинаковых столбцов. Операция деления отношения с большей арностью А на отношение с меньшей арностью Б: множество всех кортежей арности А-Б, атрибуты которых есть и в обоих отношениях.
Реляционная формула {t| F(t)}, где t–кортеж, удовлетворяющий предикату F.
Переменная называется связанной, если она стоит сразу после квантора. Безопасным называется выражение, которое истинно, если F(t) непустое множество. 
Справедлива теорема: Для любого выражения реляционной алгебры найдется эквивалентное выражение в реляционном исчислении с переменными кортежами. Причем RuS <=> {t|R(t)vS(t)}, R-S <=> {t|R(t)v~S(t)}, RxS <=> {t|сущ (u, v)| (R(u) & S(w)) & t = u x v} 
Основным формальным отличием исчисления доменов от исчисления кортежей является наличие дополнительного набора предикатов, позволяющих выражать так называемые условия членства. Если R - это n-арное отношение с атрибутами a1, a2, ..., an, то условие членства имеет вид 
  R (ai1:vi1, ai2:vi2, ..., aim:vim) (m <= n),
где vij - это либо литерально задаваемая константа, либо имя кортежной переменной. Условие членства принимает значение true в том и только в том случае, если в отношении R существует кортеж, содержащий указанные значения указанных атрибутов. Если vij - константа, то на атрибут aij задается жесткое условие, не зависящее от текущих значений доменных переменных; если же vij - имя доменной переменной, то условие членства может принимать разные значения при разных значениях этой переменной. 
Во всех остальных отношениях формулы и выражения исчисления доменов выглядят похожими на формулы и выражения исчисления кортежей. В частности, конечно, различаются свободные и связанные вхождения доменных переменных.`,
"аномалии":
`Избыточность, аномалии модификации(лишнее число операций), аномалии удаления (потеря данных), аномалии включения(появляются нулевые, неопределенные поля, в случае заключения договора, смотри пример ниже).
Поставка(название фирмы, адрес, товар, количество, цена).`,
"нормальнаяформа":
`Каждая следующая нормальная форма является более ограниченной, но более лучшей, чем предыдущая. При переходе к следующей нормальной форме положительные свойства сохраняются
Первая, вторая, третья , нормальная форма Бойса-Кодда, четвертая, пятая (или нормальная форма проекции-соединения)
Условия нахождения отношений в первой нормальной форме: все атрибуты атомарны.
96. Негативные последствия нахождение отношения лишь в первой нормальной форме.
Дублирование информации, сложности с обновлением, удалением и прочие аномалии(смотри аномалии).
97. Условия нахождения отношений во второй нормальной форме.
Находится в первой форме и каждый неключевой атрибут функционально полно зависит от первичного ключа.
98. Условия нахождения отношений в третьей нормальной форме.
Находится во второй нормальной форме и каждый неключевой атрибут нетранзитивно зависит от первичного ключа. Или каждый неключевой атрибут не является транзитивно зависимым от какого-либо ключа отношения.
99. Условия нахождения отношений в усиленной третьей нормальной форме.
Находится в третьей нормальной форме и в нем отсутствуют зависимости ключей или их частей от неключевых атрибутов.
101. Условия нахождения отношений в четвертой нормальной форме.
Находится в форме Бойса-Кодда и в нем отсутствуют многозначные зависимости, последнее возможно тогда и только тогда, когда полная декомпозиция двух проекций, в которые разнесены многозначные зависимости, содержат возможный ключ.
102. Условия нахождения отношений в пятой нормальной форме проекции-соединения. 
В каждой ее полной декомпозиции все проекции содержат возможный ключ.`,
"функциональнаязависимость":
`Функциональная зависимость– в отношении R атрибут Y функционально зависит от атрибута X (X и Y могут быть составными) в том и только том случае, если каждому значению X соответствует одно значение Y : R.X->R.Y. Бывает полная, транзитивная, частичная зависимости.
Функциональная зависимость У от Х называется полной, если атрибут У не зависит функционально от любого точного подмножества Х.
Неключевой атрибут функционально полно зависит от составного ключа,  если он функционально зависит от ключа, но не находится в функциональной зависимости ни от какой части ключа, в противном случае имеет место частичная зависимость.`,
"транзитивнаязависимость":
`Функциональная зависимость R.X->R.Y называется транзитивной, если существует такой атрибут Z , что имеется функциональные зависимости R.X->R.Z и R.Z->R.Y, и отсутствует функциональная зависимость R.Z->R.X.`,
"многозначнаязависимость":
`В отношении R(A,B,C) существует многозначная зависимость R.A->>R.B в том и только том случае, если множество значений B, соответствующее паре A C, зависит только от А и не зависит от С, т.е. для каждого значения атрибута R.A существует хорошо определенное множество соответствующих значения атрибута R.B.`,
"проецированиебезпотерь":
"Полной декомпозицией отношения называют такую совокупность произвольного числа ее проекций, соединений которых полностью совпадает с исходным отношением. При проецировании без потерь понимается такой способ декомпозиции, при котором  исходное отношение полностью и без избыточности восстанавливается путем естественного соединения полученных отношений.",
"ограничениецелостности":
`Ограничения целостности бывают: по сущностям, по ссылкам, определяемая пользователем.
Не допускается, чтобы какой-либо атрибут, участвующий в первичном ключе, принимал неопределенное значение. Для каждого внешнего ключа необходимо определить: могут ли быть нулевые значения, как удалять соответствующий первичный ключ, что будет при попытке обновления первичного ключа.
107. Средства задания ограничений целостности в языке SQL.
Запретить/ разрешить нулевые значения, задать неопределенных значения по умолчанию, контроль значений столбца, задание первичного ключа, внешнего ключа, разрешить каскадное удаление.`,
"реляционнаясхема":
`108. Процедура получения реляционной схемы из ER-схемы.
Сущность становится отношением. Атрибут–столбцом в таблице. Уникальный идентификатор становится первичным ключем. Связи «многие ко многим » и «один к одному» становятся внешними ключами. Отношения нормализуются. Учитывается целостность, создаются индексы для первичного ключа, внешнего ключа
109. Возможные подходы при построении реляционной схемы при наличии в ER-моделе подтипов.
1) все подтипы разместить в одной таблице( легкий доступ, нужно меньше таблиц, слишком общее решение, требуется дополнительная логика работы с разными наборами столбцов и разными ограничениями, неопределенные знгачения). 2) для каждого подтипа новая таблица(ясны правила подтипов, программы работают с нужными таблицами, слишком много таблиц, супертип создается с помощью UNION, над супертипом невозможны модификации.)
137. Запись операций реляционной алгебры средствами языка SQL.
:( :( :(
138. Запись операций языка SQL средствами языка реляционной алгебры.`,
"транзакция":
`Действия, которые должны быть выполнены либо все вместе, либо ни одно из них
132. Модели транзакций.
Есть альтернативные варианты транзакций. 1) транзакции с контрольными точками. Контрольные точки позволяют разделить транзакцию на несколько осмысленных фрагментов. Пользователь может зафиксировать работу в любой точке с тем, чтобы в последствии выполнить откат в состояние, соответствующее этой точке. При достижении очередной контрольной точки, транзакцией создается новое атомарное состояние, данные которого в последствии могут быть использованы в рамках той же транзакции. 2) модель многозвенных транзакций. Позволяет не только выделить потенциальное место для начала повторного выполнения некоторой части работы, но и зафиксировать ту часть работы, которая выполнена при достижении этой точки. 3) вложенные транзакции. Древовидная структура иерархии. Есть самая главная транзакция, которая всем управляет. Листья дерева транзакций– плоские транзакции. Правила управления вложенными транзакциями: правило фиксации( выполнение commit для субтранзакции делает ее результаты видимыми только родительской транзакции), правило отката ( если для некоторой нелистовой транзакции производится откат, то откатываются все ее субтранзакции), правило видимости (соседние транзакции не могут видеть друг друга, что позволяет выполнять их параллельно). Субтранзакции атомарны, целостны, изолированы. 4) многоуровневые транзакции. 
Вложенные транзакции, в которых каждая субтранзакция модет фиксировать результаты своей работы.
133. Модель распределенной обработки транзакций.
Система обработки транзакций– категория промежуточного ПО, берущая на себя роль концентраторов соединений между клиентом и сервером с тем, чтобы уменьшить число таких соединений и , во- вторых, сбалансировать и распараллелить нагрузку на сервера БД. Модель распределенной обработки транзакций описывает систему обработки транзакций начиная с базовых систем (один процесс , одна машина с одним ПО, одно множество логических данных, один узел), до сложных неоднородных распределенных систем.
Выполнение транзакции в распределенной системе управления базами данных System R*, естественно, является распределенным. Транзакция начинается в главном узле при обращении к какой-либо секции ранее подготовленного (на этапе компиляции) модуля доступа. Как и в System R, модуль доступа загружается в виртуальную память задачи, обращение к секции модуля доступа - это вызов подпрограммы. Однако, в отличие от System R, эта подпрограмма, кроме своего локального программного кода и вызовов функций RSS, содержит еще и вызовы удаленных подсекций модуля доступа. Эти вызовы интерпретируются в духе вызовов удаленных процедур. Тем самым выполнение одной транзакции, инициированной в некотором узле сети A влечет, вообще говоря, инициирование транзакций в дополнительных узлах. Основной новой по сравнению с System R проблемой является проблема согласованного завершения распределенной транзакции, чтобы результаты ее выполнения во всех затронутых ею узлах были либо отображены в состояние локальных баз данных, либо полностью отсутствовали. 
Для достижения этой цели в System R* используется двухфазный протокол завершения распределенной транзакции. Этот протокол является общеупотребимым в распределенных системах баз данных и описан во многих литературных источниках. Поэтому мы здесь опишем его очень кратко и неформально. 
Для описания протокола используется следующая модель. Имеется ряд независимых транзакций-участников распределенной транзакции, выполняющихся под управлением транзакции-координатора. Решение об окончании распределенной транзакции принимается координатором. После этого выполняется первая фаза завершения транзакции, когда координатор передает каждому из участников сообщение "подготовиться к завершению". Получив такое сообщение, каждый участник переходит в состояние готовности как к немедленному завершению транзакции, так и к ее откату. В терминах System R* это означает, что буфер журнала с записями об изменениях базы данных участника выталкиваются на внешнюю память, но синхронизационные захваты не снимаются. После этого каждый участник, успешно выполнивший подготовительные действия, посылает координатору сообщение "готов к завершению". Если координатор получает такие сообщения ото всех участников, то он начинает вторую фазу завершения, рассылая всем участникам сообщение "завершить транзакцию", и это считается завершением распределенной транзакции. Если не все участники успешно выполнили первую фазу, то координатор рассылает всем участникам сообщение "откатить транзакцию", и тогда эффект воздействия распределенной транзакции на состояние баз данных отсутствует. 
По отношению к особенностям реализации двухфазного протокола завершения транзакции в System R* заметим еще следующее. В качестве координатора выступает транзакция, выполняющаяся в главном узле, т.е. та, по инициативе которой возникли дополнительные транзакции. Тем самым, наличие центрального координирующего узла не требуется, что соответствует требованию автономности узлов. Для откатов транзакций используется базовый механизм точек сохранения System R. Наконец, классический протокол двухфазного завершения оптимизирован, чтобы сократить число необходимых сообщений. 
Как и в System R, согласованность состояния баз данных при параллельном выполнении нескольких транзакций в System R* обеспечивается на основе механизма синхронизационных захватов объектов базы данных при соблюдении двухфазного протокола захватов. Напомним, что это означает разбиение каждой транзакции с точки зрения синхронизации на две фазы - рабочую фазу, на которой захваты только устанавливаются, и фазу завершения, когда все захваты объектов базы данных, произведенные данной транзакцией, снимаются. Синхронизация производится в точности так же, как и в System R: каждая транзакция-участник обращается к локальной базе данных через RSS своего узла. Основной новой проблемой является проблема возможных распределенных тупиков, которые могут возникнуть между несколькими распределенными транзакциями, выполняющимися параллельно. (Тупики между транзакциями - участниками одной распределенной транзакции невозможны, поскольку все участники получают один общий идентификатор транзакции и не конфликтуют по синхронизации). Для обнаружения распределенных синхронизационных тупиков в System R* применяется оригинальный распределенный алгоритм, не нарушающий требования автономности узлов сети и минимизирующий число передаваемых по сети сообщений и необходимую процессорную обработку. 
Основная идея алгоритма состоит в том, что в каждом узле периодически производится анализ на предмет существования тупика с использованием информации о связях транзакций по ожиданию ресурсов, локальной в данном узле и полученной от других узлов. При проведении этого анализа обнаруживаются либо циклы ожиданий, что означает наличие тупика, либо потенциальные циклы, которые необходимо уточнить в других узлах. Эти потенциальные циклы представляются в виде специального вида строк. Строка представляет собой по сути дела список транзакций. Все транзакции упорядочены в соответствии со значениями своих идентификаторов ("номеров транзакций"). Строка передается для дальнейшего анализа в следующий узел (узел, в котором выполняется самая правая в строке транзакция) только в том случае, если номер первой транзакции в строке меньше номера последней транзакции. (Это оптимизация, уменьшающая число передаваемых по сети сообщений). Этот процесс продолжается до обнаружения тупика. 
Если обнаруживается наличие синхронизационного тупика, он разрушается за счет уничтожения (отката) одной из транзакций, входящей в цикл. В качестве жертвы выбирается транзакция, выполнившая к этому моменту наименьший объем работы. Эта информация также передается по сети вместе со строками, описывающими связи транзакций по ожиданию.`,
"параллелизм":
`1) проблема утраченного обновления, 2) проблема зависимости от незафиксированного обновления, 3) проблема анализа на непротиворечивость.
119. Эффекты параллелизма.
Пусть Программа1 выбирает строки, Программа2 их модифицирует, а при выполнении некоторого условия совершает откат. Возможно четыре исхода. 1) программа2 заканчивается раньше, чем программа1 выберет хотя бы одну строку. 2) Программа1 выбрала все строки, прежде чем вторая начала делать изменения. 3) Программа1 находится в работе, программа2 меняет строки, и ответ программы1 состоит из смеси старых и новых значений. 4) в случае 3) программа 2 может произвести откат, тогда программа1 выдаст измененные строки, которые на самом деле не изменены в базе.`,
"изолированность":
`Изолированность– дисциплина регулирования совместного выполнения транзакций. Необходимо: 1) чтобы пользователь(программа) видел только согласованные состояния БД. Пользователь не должен иметь  доступа к незафиксированным данным, полученным в результате работы другого пользователя. 2) если две транзакции выполняются параллельно, то СУБД полагает, что результат должен не зависеть от того, какая выполнится первой.
Уровни изолированности: 1) уровень грязного (неподтвержденного) чтения. Гарантирует отсутствие потерянных изменений, но не устанавливает ограничений на чтение данных. Для обеспечения этого уровня требуется, чтобы до завершения изменения объекта транзакции А никакая другая транзакция не могла изменить объект. 2) уровень подтвержденного чтения. Он гарантирует , что сервер никогда не вернет строку, не подтвержденную в БД. Чтобы избежать чтения грязных данных до завершения транзакции А, изменяющей исходный объект, никакая другая транзакция не должна читать. 3) уровень повторяемого чтения. А читает, В меняет, А опять читает. Чтобы избежать различных результатов при чтении одного объекта, никакая другая транзакция не должна менять этот объект. 4) фантомный, способный к упорядочиванию уровень.`,
"смесь":
"Набор из нескольких транзакций, элементарные операции которых чередуются между собой, называется смесью транзакций. Последовательность, в которой выполняются операции на заданном наборе транзакций, называется графиком запуска набора транзакций. График должен 1) обеспечивать изолированность пользователей и предотвращать возникновение коллизий, 2) быть оптимальным по времени.",
"сериализация":
`Сериализация транзакций – механизм их выполнения по некоторому сериальному плану. Сериальный план транзакций – способ их выполнения, при котором эффект совместного выполнения транзакций эквивалентен результату некоторого их последовательного выполнения.
При организации параллельной работы решаются два вопроса: 1) установление блокировок, 2) уменьшение числа и размера блокируемых фрагментов, не вызываю при этом конфликтов. Транзакции называются конфликтующими, если они пересекаются по времени и обращаются к одному участку памяти.`,
"конфликт":
`1. Вторая транзакция пытается обновить объект, обновленный первой незакончившейся транзакцией. Результат: возможная потеря обновления.
2. Вторая транзакция пытается изменить объект, читаемый первой транзакцией. Проблема анализа результата на непротиворечивость
3. Вторая транзакция пытается читать объект, измененный незакончившейся транзакцией. Чтение грязных данных.`,
"синхронизациязахватов":
`Основная идея метода в том, что перед выполнением любой операции в некоторой транзакции над объектом от имении транзакции запрашивается захват объекта в соответствующем режиме. Режим может быть совместным и монопольным. Правила синхронизированного захвата: 1)если транзакция А захватывает объект О в монопольном режиме, то запрос любого типа из транзакции В на захват объекта О приведет к тому, что транзакция В перейдет в состояние ожидания и будет находиться в этом состоянии до тех пор, пока транзакция А не снимет блокировку с О.2) если транзакция А захватывает О в совместном режиме, тогда а) запрос В на захват в монопольном режиме приведет к переходу В в состояние ожидания до снятия блокировки с О, установленной А; б) запрос из В на захват О в совместном режиме будет удовлетворен и транзакция В будет также удерживать блокировку объекта О.
Таблица совместных захватов:
	X	s	–
X	n	n	y
S	n	y	y
–	y	y	y
Виды блокировок: всю БД, отдельное отношение, блокировка страницы данных (несколько строк таблицы), блокировка кортежа.
126. Предикатные синхронизационные захваты.
Метод позволяет захватывать не индивидуальные объекты, а условия, которым удовлетворяют эти объекты. Каждому отношению соответствует n-мерное пространство кортежей, а условие вырезает в нем  прямоугольник меньшей либо равной размерности. Говорят, что предикатные захваты от разных транзакций совместимы, если их прямоугольники не пересекаются.
127. Решение на основе аппарата синхронизационных захватов проблем, связанных с параллелизмом.
1.) проблема зависимости от незафиксированного обновления, 2) проблема повторяемого чтения , 3) проблема появления фиктивных элементов, 3) анализ на противоречивость. Синхронизированные захваты порождают тупиковые ситуации. Применение метода связано с определенным замедлением обработки транзакций, т.к. необходимо снятие блокировки.`,
"гранулированный":
`Вводится специальный протокол захватов: намерение захватить часть составного объекта О в совместном режиме, намерение захватить часть составного объекта О в монопольном режиме, совместный захват всего объекта с намерением впоследствии захватить входящие в него объекты в монопольном режиме.
Таблица совместимых захватов:
	Is	s	ix	six	x	–
Is	y	y	y	y	n	y
S	y	y	n	n	n	y
Ix	y	n	y	n	n	y
Six	y	n	n	n	n	y
X	n	n	n	n	n	y
–	y	y	y	y	y	y
При захвате Х для сложного объекта неявным образом выполняется захват Х всех его частей. При захвате s или Six неявно подразумевается S для всех входящих в объект частей. Прежде чем осуществить захват s или is данного объекта транзакция должна выполнить захват типа is или более сильный по крайней мере для одного родительского объекта этого объекта. Прежде чем осуществить захват х или iх данного объекта транзакция должна выполнить захват типа iх или более сильный по крайней мере для одного родительского объекта этого объекта. Прежде чем для данного объекта будет отменен захват, должен быть отменен захват каждой его части. Сила захвата убывает от x > Six> s, ix > is. Так можно решить задачу фиктивных элементов.`,
"тупиковаяситуация":
`Основой для обнаружения тупиков является построение и постоянное поддержание ориентированного графа ожидания транзакции. Граф двудольный, два типа вершин– вершины- транзакции и вершины- объекты захвата. Ребро, ведущее от транзакции к объекту,– для этой транзакции существует удовлетворенный захват данного объекта. Ребро от объекта к транзакции– транзакция ожидает захвата объекта. Если в системе существует тупиковая ситуация, то в графе ожидания транзакций существует хотя бы 1 цикл. Стандартный метод нахождения тупиков – метод редукции графа. Первый этап: удалить все дуги, выходящие из транзакций, в которые не входит ни одна дуга ( транзакции, не ожидающие удовлетворения захватов, завершились и освободили захват). Второй этап: Для вершин объектов, в которые не входят дуги, но существуют исходящие, одна из исходящих дуг меняется на противоположную( имитация удовлетворения захвата). Переход к этапу 1. Если в графе останутся неудаляемые дуги, то был цикл.
129.	Разрушение тупиков.
После нахождения цикла СУБД уничтожает его. Выбирается транзакция- жертва. Эта транзакция должна быть дешевой. Ее откатывают, и все ее объекты освобождаются, и, возможно, тупик будет разрушен.
130.	Метод временных меток.
Если транзакция Т началась раньше транзакции Т1, то система выбирает такой режим работы, как если бы транзакция Т была целиком выполнена до начала выполнения Т1. Для этого каждой транзакции приписывается временная метка. При выполнении операции над объектом, он помечается меткой соответствующей транзакции. Другая транзакция Т1 проверяет: 1) Если Т закончилась, то Т1 помечает объект своей меткой и начинает работу. 2) если Т не завершилась и ситуация неконфликтна, то Т1 ставит метку и начинает работу. 3) Если ситуация конфликтна, а Т началась позже Т1, то Т откатывается, а Т1 продолжает работу. 4) Если ситуация конфликтная, Т1 началась позже Т, Т1 получает новую временную метку и начинается заново. Недостатки: потенциально более частые откаты транзакций, в распределенных системах выработать глобальные метки сложно. Достоинство: нет необходимости распознавать тупики.
131. Метод выделения версий данных.
Применяется в тех ситуациях, когда есть транзакции только меняющие и только читающие данные. Транзакциям, только читающим данные, предоставляется своя версия данных, существующая к моменту начала транзакции. Для каждой транзакции запоминается текущий системный номер. Чем позже начата транзакция, тем больше ее системный номер. При записи страницы на диск фиксируется системный номер транзакции, производящей эту запись, при этом системный номер становится текущим системным номером страницы данных. Транзакции , только читающий данные ничего не блокируют в БД. Если системный номер страницы данных меньше системного номера читающей транзакции, то транзакция читает страницу, иначе читающая транзакция просматривает журнал в поиске первой записи с меньшим номером транзакции и использует соответствующее ей состояние страницы данных.`,
"операторsql":
`DELETE FROM table-name
[WHERE
{condition }]
INSERT 
INTO table-name [(column-list)] 
{VALUES( value-list) 
| SELECT-statement} 
SELECT 
[ALL | [DISTINCT | UNIQUE]] select-list 
[INTO variable-list] (C-ESQL)
FROM откуда выбирается
{ table-name [table-alias] 
| OUTER table-name [table-alias] для создания
}[,....] внешнего соединения
[WHERE condition] условие выбора строк
[GROUP BY column-list] группирование
[HAVING condition] условие в группах
[ORDER BY column-list [ASC | DESC][,...]] сортировка
[INTO TEMP table-name]
UPDATE table-name SET модификация строки таблицы;
{column-name=expr[, ...] имена столбцов и 
присваиваемые им значения
| {(column-list) список столбцов
| [table-name.]*}={(expr-list) }
}
[WHERE {condition}
}
LOAD вставка данных из ASCII-файла в таблицу;
FROM "pathname" [DELIMITER "char"] путь к файлу и разделитель полей
{INSERT INTO table-name[(column-name [, ...])] имя
таблицы и столбцы для вставки
| insert-statement 
} 
UNLOAD выдача результата работы SELECT в ASCII-файл;
TO "pathname" [DELIMITER "char"] путь к файлу и разделитель полей
SELECT-statement оператор SELECT`,
"подзапрос":
`Оператор select, вложенный в спецификатор where другого оператора select (или одного из операторов insert, delete, update), называется подзапросом. В состав каждого подзапроса должны входить спецификаторы select и from. Кроме того, каждый подзапрос должен быть заключен в круглые скобки, чтобы указать серверу баз данных на то, что эту операцию следует выполнить первой. Подзапросы бывают коррелированными и некоррелированными. Подзапрос является коррелированным, если его значение зависит от значения, производимого внешним оператором select, который содержит этот подзапрос. Любой другой вид запроса называется некоррелированным. Важное свойство коррелированного подзароса состоит в следующим: так как он зависит от значения результата внешнего оператора select, то должен выполняться повторно по одному разу для каждого значения, производимого внешним оператором select. Некоррелированный подзапрос выполняется только один раз. В коррелированном подзапросе внутренний подзапрос не может быть отработан раз и навсегда, прежде чем будет отработан внешний запрос, поскольку этот внутренний подзапрос зависит от переменной, значение которой изменяется по мере того, как система проверяет различные строки таблицы, участвующие во внешнем запросе.`,
"соединение":
`1)Простое эквисоединение: Select S.*,P.* from S, P. 2) Эквисоединение с дополнительным условием: Select S.номер_поставщика, p.номер_детали, рейтинг from S, P where S.город=P.город and S.рейтинг<>20. 3) соединение таблицы с ней самой: Select one.номер_поставщика, two.номер_поставщика from S one, S two where one.город = two.город and one.номер_поставщика < two.номер_поставщика. 4) соединение трех таблиц.
В простом соединении результат содержит только комбинации строк из тех таблиц, которые удовлетворяют условиям соединения. Строки, которые не удовлетворяют условиям соединения, отбрасываются. Во внешнем соединении результат содержит комбинации строк из тех таблиц, которые удовлетворяют условиям соединения, а также строки, которые были бы отброшены при простом соединении этих таблиц, даже если в подчиненной таблице не найдена ни одна соответствующая строка. Строки главной таблицы, для которых не найдено в подчиненной таблице ни одной соответствующей строки, получают значения, состоящие из одних Null-значений для каждого столбца.
Существует четыре основных типа внешних соединений:
•	простое внешнее соединение; 
Select S.номер_поставщика, S.фамилия, SP.количество  from S, outer SP where S.номер_поставщика=SP.номер_поставщика
Добавление ключевого слова outer перед именем таблицы SP превращает ее в подчиненную таблицу. Результатом этого внешнего соединения будет получение сведений обо всех поставщиках, независимо делали ли они поставки.
•	простое внешнее соединение с третьей таблицей; 
•	внешнее соединение простого соединения с третьей таблицей; 
select S.номер_поставщика, S.фамилия, SP.номер_детали,  P.название, P.цвет, P.вес from S, outer(SP, P) where S.номер_поставщика = SP.номер_поставщика and P.номер_детали =SP.номер_детали  and цвет in ("Красный", "Зеленый") 
Оператор select выполняет сначала простое соединение таблиц SP и P, а затем этот оператор выполняет внешнее соединение как комбинирование этой информации с данными из главной таблицы S.
•	внешнее соединение внешнего соединения с третьей таблицей.
select S.номер_поставщика, S.фамилия, SP.номер_детали, P.название, P.цвет, P.вес from S, outer(SP, outer P) where S.номер_поставщика = SP.номер_поставщика and  SP.номер_детали = P.номер_детали   And  цвет in ("Красный", "Зеленый")
Оператор select сначала выполняет внешнее соединение таблиц SP и P, затем - внешнее соединение как комбинирование этой информации с данными из главной таблицы S.`,
"представления":
`Специальные операторы языка SQL позволяют определять так называемые представления БД, фактически являющиеся хранимыми в БД запросами (результатом любого запроса к реляционной БД является таблица) с именованными столбцами. Для пользователя представление является такой же таблицей, как любая базовая таблица, хранимая в БД, но с помощью представлений можно ограничить или наоборот расширить видимость БД для конкретного пользователя. Поддержание представлений производится также на языковом уровне.`,
"sql":
`140. Достоинства и недостатки языка SQL.
141. Классические правила использования конструкций языка SQL.
1) индексирование. 2) для фильтрации записей вместе с фразой group by на индексированных столбцах индекс не используется. Фильтровать надо с помощью where. 3) минимизировать число просматриваемых таблиц. 4)rowid  в приложениях не использовать, т.к. его значение непостоянно. 5) избыточность в where может ускорить выборку.6) избегать соединения. 7) фильтровать строки на более ранних этапах запроса. Соединять строки так, чтобы главная таблица содержала минимальное число строк. 8) сложный запрос разбить на простые, используя временные таблицы. 9) проще писать надо.`,
"индексирование":
`CREATE INDEX index-name ON table-name (column-name [ASC | DESC] [,...])
1) индексы следует создавать, когда число строк боле  200. 2) создавать индексы для столбцов, которые часто используются в конструкции where. 3) Создавать индексы для столбцов, участвующих в соединении. 4) индексируются столбцы с небольшим количеством строк с одним и тем же значением.5) не следует индексировать столбцы, используемые в функциях. 6)не индексировать часто изменяемые столбцы. 7) Не индексировать, если это снижает эффективность. 8) создать кластерный индекс– с физическим переупорядочиванием строк.`,
"клиентсервер": `Программа-клиент выполняет первичную и конечную обработку данных. Сервер занимается организацией таблиц в БД, в физической памяти, управляет выборкой.
144. Преимущества модели "клиент-сервер" в сравнении с традиционной моделью обработки данных.
1) перенос программ управления данными на сервер способствует высвобождению ресурсов рабочей станции. Компы- клиенты могут быть простой конфигурации. 2) серверная часть содержит наиболее важные функции управления данными, орудия их защиты. 3) за счет того, что объем передаваемых данных невелик, снижается трафик сети.
146. Три модели архитектуры "клиент-сервер", их достоинства и недостатки.
1) модель доступа к удаленным данным. 2) модель сервера БД. 3) модель сервера приложений.`,
"логическиекомпоненты": "В каждом приложении выделяются три логические компоненты: 1) компонент представления, выполняющий ввод и вывод данных, 2) прикладной компонент, 3) компонент доступа к информационным ресурсам.",
"сервер":
`Процесс, выполняющийся на машине клиента отвечает только за ввод и отображение данных. Прикладные функции выполняются группой процессов (серверов приложений), функционирующей на удаленном компе (группе компов). Доступ к данным осуществляется аналогично модели «доступа к удаленным данным». Сервера приложений являются одной из категорий промежуточного ПО. Функции сервера приложений: 1) предоставление пользователю средств разработки программ для сервера приложений. 2) защита ресурсов, администрирование и контроль доступа к распределенным ресурсам.3) оптимальное распределение нагрузки путем распараллеливания работ между различными процессами сервера приложений или различными серверами приложений. 4) управление сервером и транзакциями. Это новая, неустоявшаяся технология.
Сервер называется активным, если он адекватно отражает процессы,. Поэтому задачи активного сервера: 1) БД всегда должна правильно отражать состояние предметной области и данные в ней не должны быть противоречивы. 2) БД должна правильно отражать правила предметной области, по которым она функционирует. 3) контроль за изменениями и реакция на них. 4)возникновение некоторых ситуаций в БД влияет на ход выполнения прикладных программ.
149. Традиционный подход к работе с сервером.
Реализуется в прикладных программах. Программы становятся сложными, изменение правил ведет к переписыванию программ, отсутствует контроль за непротиворечивостью правил.`,
"ограничение": "Ограничение– то, что ассоциируется с таблицами или столбцами таблицы.",
"утверждение": "Утверждение– самостоятельная декларация, затрагивающая несколько таблиц и хранящаяся в БД наряду с таблицами. Create ascertation NAME check (select …)",
"хранимаяпроцедура":
`Объект, хранимый непосредственно в БД и управляемый сервером БД. Они уменьшают время обработки запроса (не включают синтаксический анализ и оптимизацию); сокращают трафик, т.к. передаются только параметры; могут использоваться несколькими прикладными программами одновременно; хорошее средство вместе с триггерами для поддержания целостности.
Create procedure NAME( p1 type1,p2 type2…) returning type1, type2…операторы через «;» end procedure. Вызывается Execute procedure NAME (par1, par2…) R1,R2…Из другой процедуры вызывается Call NAME (par1, par2…) R1, R2…Локальные переменные создаются оператором define NAME type. Значения переменным присваиваются let NAME= {выражение, например, select }. Возможны следующие операторы : if …end if; for…end for; while…do while; foreach… end foreach. Continue & return par1, par2…– как в нормальном языке. On exeption in (коды ошибок) действия(все через “;”) end exeption.
152. Средства организации хранимых процедур (язык SPL).
Смотри выше.`,
"триггер":
`Позволяют обрабатывать изменения БД. Create trigger NAME [insert | update | delete ] on [имя таблицы / в случае обновления of имя столбца on имя таблицы ] {referencing [new | old] as название} {for each row} when (условие активации триггера) действие(вызов процедуры execute procedure). В триггере можно через «;» перечислять действия до и после события. Referencing всегда используется с for each.
154. Средства написания триггеров.
Смотри выше`,
"событие":
`Механизм событий позволяет прикладной программе и серверу БД уведомить другие программы о некотором событии и тем самым синхронизировать их выполнение. Create dbevent имя события. Вызов события raise dbevent имя события. Программа регистрируется как получатель события register dbevent. get dbevent имя процедуры(Имя события=Dbeventname, ее параметры ). В этой процедуре проверяется название события. Если оно известно, то что-то делается.`,
"функция":
`Часто нужно разрабатывать подпрограммы, которые решают сходные задачи, но выполняют различную логику в зависимости от аргументов - перегружаемые функции.
Имея одинаковые имена, они обладают разными сигнатурами, которые включают:
•	тип подпрограммы (процедура или функция); 
•	имя подпрограммы; 
•	количество параметров; 
•	типы данных параметров; 
•	порядок следования параметров. 
При вызове сервер ищет подпрограмму, сигнатура которой соответствует указанной.`,
"сигнатура": "Название, список параметров процедуры или функции.",
"сложныйтипданных":
`Данные типа множества (Set).
Сложные типы данных подразделяются на коллекции; строчные типы; типы данных, определенные пользователем. 
Коллекции в свою очередь делятся на: множества (SET); мультимножества (MULTISET); списки (LIST), а строчные типы данных могут быть поименованными и непоименованными
Коллекции представляют собой сложный тип, составленный из отдельных элементов, каждый из которых принадлежит к одному и тому же типу данных, при этом элементы сами могут быть сложными типами, встроенными типами или типами, определенными пользователем.
Коллекция SET является множеством уникальных неупорядоченных элементов (без дублирования). Коллекция MULTISET не упорядочена, подобно SET, но допускает дублирующие значения. Set {“ха”,”хи”,”хо”}. multiset {“ха”,“ха”,”хи”,”хо”}. В отличии от SET и MULTISET коллекция LIST является упорядоченным множеством элементов, где допустимы дублирующие значения. list{“ха”,“ха”,”хи”,”хо”,…}
160. Сложные типы данных. Данные типа мультимножества (MultiSet).
161. Сложные типы данных. Данные типа списков (List).
162. Сложные типы данных. Строчные типы данных.
В отличии от коллекций строчные типы являются группами элементов разных типов и формируют шаблон записи, который впоследствии можно использовать при определении таблиц. Create row type NAME (name1 type1, name2 type2,…) create table NAME_table of type NAME. При добавлении такого строчного значения пишется row(p1,p2,…)::NAME. Для обращения к отдельному полю NAME.name*. Возможно вложение двух строчечных типов. Можно не вводить row, а писать сразу при создании таблицы.`,
"наследование":
`Наследование представляет собой возможность одному объекту приобретать свойства другого объекта, например, если одна таблица определяется как подтаблица другой, то она наследует поведение супертаблицы (ограничения, триггеры, индексы, функции и пр.). Аналогично строчный тип, определенный как подтип базового типа, наследует поля данных и поведение супертипа. 
Create table t2 of type NAME under t3. Если нужно работать только с супертипом пишется …Only(супертип)`,
"пользовательскийтипданных":
`Create distinct type NAME as известный тип.
Определенный пользователем тип данных основан на существующем типе, как встроенном так и сложном.`,
"приведение":
`Функция приведения (casting) выполняет операции, необходимые для преобразования данных одного типа в другой. Приведения могут:  неявные, для чего сервер имеет множество встроенных функций приведения между всеми базовыми типами; например, приведение от десятичного к целому будет включать усечение десятичных цифр после запятой, любой определенный пользователем тип преобразуется по умолчанию в lvchar; и возможно явное приведение между новым типом и типом-источником; 
В случае явных приведений необходимо использовать оператор приведения <источник>::<новый тип>`,
"классификацияинформационныхсистем":
`В области информационных технологий существуют два класса информационными систем (и соответственно, два класса задач):  OLTP-системы и DSS-системы. Все остальное было раньше.`,
"fasmi":
`Codd сформулировал 12 принципов OLAP, которые позже были переработано в так называемый тест FASMI:
•	Fast (быстрый) - предоставление пользователю результатов анализа за приемлемое время (обычно не более 5 с), пусть даже ценой менее детального анализа; 
•	Analysis (анализ) - возможность осуществления любого логического и статистического анализа, характерного для данного приложения, и его сохранения в доступном для конечного пользователя виде; 
•	Shared (разделяемой) - многопользовательский доступ к данным с поддержкой соответствующих механизмов блокировок и средств авторизованного доступа; 
•	Multidimensional (многомерной) - многомерное концептуальное представление данных, включая полную поддержку для иерархий и множественных иерархий (ключевое требование OLAP); 
•	Information (информации) - возможность обращаться к любой нужной информации независимо от ее объема и места хранения.`,
"хранилищеданных":
`Для того, чтобы извлекать полезную информацию из данных, они должны быть организованы способом, отличным от принятого в OLTP-системах В OLTP-системах используются нормализованные таблицы базы данных. Нормализация эффективна, если отношения часто перестраиваются (вставка,. . .), но дает отрицательный эффект в случае операции выборки (особенно в случае сложных запросов). А в DSS-системах только операции выборки, и данные редко меняются, поэтому данные целесообразно хранить в виде слабо нормализованных отношений, содержащих заранее вычисленные основные итоговые данные. Большая избыточность и связанные с ней проблемы тут не страшны, т.к. обновление происходит только в момент загрузки новой порции данных. При этом происходит как добавление новых данных, так и пересчет итогов. Выполнение некоторых аналитических запросов требует хронологической упорядоченности данных. Реляционная модель не предполагает существования порядка записей в таблицах. В случае аналитических запросов чаще используются не детальные, а обобщенные (агрегированные данные). 
В результате данные, применяемые для анализа, стали выделять в отдельные специальные базы данных, впоследствии получивших название хранилищ данных (Data Warehouse).
Хранилище данных (определение Билла Инмона(Bill Inmon)) - предметно-ориентированный, интегрированный, привязанный ко времени и неизменяемый набор данных, предназначенный для поддержки принятия решений.
174. Принципы построения хранилищ данных.
•	Ориентация на предметную область. Хранилище должно разрабатываться с учетом специфики предметной области (клиенты, товары, продажи), а не прикладных областей деятельности (выписка счетов, контроль запасов, продажа товаров). 
•	Интегрированность и внутренняя непротиворечивость. Поскольку данные в хранилище поступают из разных источников (OLTP-системы, архивы и пр.), необходимо привести их к единому формату (дата: 5 января, 5.01,:). В процессе загрузки хранилища должна быть обеспечена, очистка и согласованность данных. 
•	Привязка ко времени. Учет хронологии достигается введением атрибутов "Дата" и "Время". Упорядочение по этим атрибутам позволяет сократить время выполнения аналитических запросов. 
•	Неизменяемость. Данные не обновляются в оперативном режиме, а лишь регулярно пополняются из систем оперативной обработки по заданной дисциплине. 
•	Поддержка высокой скорости получения данных из хранилища. 
•	Возможность получения и сравнения так называемых срезов данных (slice and dice); 
•	Полнота и достоверность хранимых данных; 
•	Поддержка качественного процесса пополнения данных. 
175. Многомерная модель хранилищ данных (MOLAP).
В MOLAP-модели многомерное представление данных реализуется физически. В специализированных СУБД, основанных на многомерном представлении данных, данные организованы не в форме реляционных таблиц, а в виде упорядоченных многомерных массивов:
7.	гиперкубов (все хранимые в базе данных ячейки должны иметь одинаковую размерность, то есть находиться в максимально полном базисе измерений) и 
8.	поликубов (каждая переменная хранится с собственным набором измерений, и все связанные с этим cложности обработки перекладываются на внутренние механизмы системы). 
Использование многомерных баз данных в системах оперативной аналитической обработки имеет следующие достоинства: 
•	Высокая производительность. В случае использования многомерных СУБД поиск и выборка данных осуществляется значительно быстрее, чем при многомерном концептуальном взгляде на реляционную базу данных, так как многомерная база данных денормализована, содержит заранее агрегированные показатели и обеспечивает оптимизированный доступ к запрашиваемым ячейкам. 
•	Многомерные СУБД легко справляются с задачами включения в информационную модель разнообразных встроенных функций, тогда как объективно существующие ограничения языка SQL делают выполнение этих задач на основе реляционных СУБД достаточно сложным, а иногда и невозможным. 
Недостатки MOLAP-модели:
•	Многомерные СУБД не позволяют работать с большими базами данных. 
•	Многомерные СУБД по сравнению с реляционными очень неэффективно используют внешнюю память. В подавляющем большинстве случаев информационный гиперкуб является сильно разреженным, а поскольку данные хранятся в упорядоченном виде, неопределенные значения удаётся удалить только за счет выбора оптимального порядка сортировки, позволяющего организовать данные в максимально большие непрерывные группы. Но даже в этом случае проблема решается только частично. Кроме того, оптимальный с точки зрения хранения разреженных данных порядок сортировки скорее всего не будет совпадать с порядком, который чаще всего используется в запросах. 
Следовательно, использование многомерных СУБД оправдано только при следующих условиях:
1.	Объем исходных данных для анализа не слишком велик (не более нескольких гигабайт), то есть уровень агрегации данных достаточно высок. 
2.	Набор информационных измерений стабилен (поскольку любое изменение в их структуре почти всегда требует полной перестройки гиперкуба). 
3.	Время ответа системы на нерегламентированные запросы является наиболее критичным параметром. 
Примеры OLAP-серверов, использующих MOLAP-архитектуру: Oracle Express Server фирмы Oracle, Microsoft SQL Server 2000 Analysis Server фирмы Microsoft.
176. Реляционная модель хранилищ данных (ROLAP). Схема "звезда".
Системы оперативной аналитической обработки реляционных данных (ROLAP) позволяют представлять данные, хранимые в реляционной базе, в многомерной форме, обеспечивая преобразование информации в многомерную модель через промежуточный слой метаданных. В этом случае гиперкуб эмулируется СУБД на логическом уровне.
Для большинства хранилищ данных наиболее эффективным способом моделирования N-мерного куба фактов является схема "звезда" (star schema).
Основными составляющими структуры хранилищ данных являются таблица фактов (fact table) и таблицы измерений (dimension tables). 
Таблица фактов является основной таблицей хранилища данных. Как правило, она содержит сведения об объектах или событиях, совокупность которых будет в дальнейшем анализироваться. Если проводить аналогию с многомерной моделью, то строка таблицы фактов соответствует ячейке гиперкуба. Обычно говорят о четырех наиболее часто встречающихся типах фактов. К ним относятся: 
•	факты, связанные с транзакциями (Transaction facts). Они основаны на отдельных событиях (типичными примерами которых являются телефонный звонок или снятие денег со счета с помощью банкомата); 
•	факты, связанные с "моментальными снимками" (Snapshot facts). Основаны на состоянии объекта (например, банковского счета) в определенные моменты времени, например на конец дня или месяца. Типичными примерами таких фактов являются объем продаж за день или дневная выручка; 
•	факты, связанные с элементами документа (Line-item facts). Основаны на том или ином документе (например, счете за товар или услуги) и содержат подробную информацию об элементах этого документа (например, количестве, цене, проценте скидки); 
•	факты, связанные с событиями или состоянием объекта (Event or state facts). Представляют возникновение события без подробностей о нем (например, просто факт продажи или факт отсутствия таковой без иных подробностей). 
Таблица фактов индексируется по сложному ключу, составленному из ключей отдельных измерений. При этом как ключевые, так и некоторые неключевые поля таблицы фактов должны соответствовать будущим измерениям OLAP-куба. Помимо этого таблица фактов содержит одно или несколько числовых полей, на основании которых в дальнейшем будут получены агрегатные данные. 
Замечания.
Для многомерного анализа пригодны таблицы фактов, содержащие как можно более подробные данные, то есть соответствующие членам нижних уровней иерархии соответствующих измерений. В таблице фактов отсутствуют какие-либо сведения о том, как группировать записи при вычислении агрегатных данных. 
Таблица измерений содержит неизменяемые или редко изменяемые данные. В каждой таблице измерений перечислены возможные значения одного из измерений гиперкуба. В подавляющем большинстве случаев эти данные представляют собой по одной записи для каждого члена нижнего уровня иерархии в измерении. Таблицы измерений также содержат как минимум одно описательное поле (обычно с именем члена измерения) и, как правило, целочисленное ключевое поле (обычно это суррогатный ключ) для однозначной идентификации члена измерения. Каждая таблица измерений должна находиться в отношении "один ко многим" с таблицей фактов.
Причина, по которой данная схема названа "звездой" достаточно очевидна. Концы звезды образуются таблицами измерений, а их с таблицей фактов, расположенной в центре, образуют лучи. В терминологии Кодда, каждый луч схемы звезды задает направление консолидации данных по соответствующему измерению. 
177. Реляционная модель хранилищ данных (ROLAP). Схема "снежинка".
В сложных задачах с многоуровневыми измерениями используются различные расширения схемы "звезда" - схема "снежинка" (snowflake schema). Это расширение может проявляться в двух разновидностях.
1. В случае большого числа сложных атрибутов в таблице измерений, некоторые атрибуты могут быть детализированы в отдельных таблицах измерений. Иными словами отдельные измерения содержатся не в одной, а в нескольких связанных между собой таблицах. Дополнительные таблицы измерений в такой схеме, обычно соответствующие верхним уровням иерархии измерения и находящиеся в соотношении "один ко многим" в главной таблице измерений, соответствующей нижнему уровню иерархии, иногда называют консольными таблицами (outrigger table). 
2. Другое расширение связано с созданием отдельных таблиц фактов для всех возможных сочетаний уровней обобщения различных измерений. 
Увеличение числа таблиц фактов в базе данных может проистекать не только из множественности уровней различных измерений, но и из того обстоятельства, что в общем случае факты имеют разные множества измерений. При абстрагировании от отдельных измерений пользователь должен получать проекцию максимально полного гиперкуба, причем далеко не всегда значения показателей в ней должны являться результатом элементарного суммирования. Таким образом, при большом числе независимых измерений необходимо поддерживать множество таблиц фактов, соответствующих каждому возможному сочетанию выбранных в запросе измерений.
Это позволяет добиться лучшей производительности, но часто приводит к избыточности данных и к значительным усложнениям в структуре базы данных, в которой оказывается огромное количество таблиц фактов
178. Расширения языка SQL для хранилищ данных.
Теоретически реляционная база данных звездообразной структуры обеспечивает хороший фундамент для выполнения произвольных, нерегламентированных запросов из области делового анализа. Однако между типичными аналитическими запросами и возможностями базового языка SQL имеются серьезные несоответствия:
•	Сортировка данных. Многие аналитические запросы явно или неявно требуют предварительной сортировки данных (первые 10%, самые низкоприбыльные и т.п.). Однако SQL оперирует с несортированными строками. Единственным средством сортировки является фраза Order by в операторе Select, причем сортировка выполняется в самом конце процесса, когда данные уже отобраны. 
•	Хронологические последовательности. Многие запросы к хранилищам данных предназначены для анализа изменения некоторых показателей во времени (сравнение результатов одного года с другим, одного месяца некоторого года с результатами некоторого месяца другого года). Средствами стандартного SQL это зачастую сделать весьма трудно. 
•	Сравнение с итоговыми данными. Многое аналитические запросы сравнивают значения отдельных элементов (например, объемы продаж отдельных офисов) с итоговыми данными (например, объемами продаж по регионам). Такой SQL-запрос трудно выражаем средствами SQL. А сводный отчет классического формата - с детальными данными, промежуточными и сводными итогами - единым SQL-запросом вообще не выразить, поскольку структура всех строк запроса должна быть одинаковой. 
Решая эти проблемы, производители СУБД предлагают расширения SQL для аналитической обработки. Например, СУБД Red Brick одноименной фирмы, которая впоследствии бала куплена компанией Informix, а та соответственно IBM в язык RISQL (Red Brick Intelligent SQL) включены следующие расширения:
•	диапазоны - позволяет сформировать запросы типа "отобрать первые 10 записей" (функция Rank . . .when); 
•	перемещение итогов и средних - используется для хронологического анализа, требующего предварительной обработки данных; 
•	расчет текущих итогов и средних - позволяет получать данные по отдельным месяцам плюс годовой итог на текущую дату и выполнять подобные запросы (функция Cume для вычисления текущего и общего итога для некоторого столбца, функции Movingavg(n) и Movingsum(n) для вычисления скользящего среднего и скользящей суммы по столбце на основе текущей и (n-1) предыдущих строк); 
•	сравнительные коэффициенты - позволяет создавать запросы, выражающие отношения отдельных значений к общим и промежуточным итогам без использования сложных вложенных запросов; 
•	промежуточные итоги - позволяет получать результаты запросов, в которых объединена детализированная и итоговая информация, причем с несколькими уровнями итогов (функция Tertile); 
•	декодирование - производит замену кодов из таблиц измерений понятными именами (функция Decode). 
179. Архитектура хранилища данных. Основные его компоненты.
Менеджер загрузки (load manager) выполняет операции, связанные с извлечением и загрузкой данных в хранилище.
Менеджер хранилища (warehouse manager) выполняет операции, связанные с управлением информацией, помещенной в хранилище данных:
•	анализ непротиворечивости данных; 
•	создание индексов и представлений для базовых таблиц; 
•	денормализация данных (при необходимости); 
•	обобщение данных (при необходимости); 
•	резервное хранение и архивирование. 
Менеджер запросов (query mamager) выполняет операции, связанные с управлением пользовательскими запросами.`,
"интеллектуальныйанализ":
`Интеллектуальный анализ данных (ИАД - Data Mining) - это процесс поддержки принятия решений, основанный на поиске в данных скрытых закономерностей. При этом накопленные сведения автоматически обобщаются до информации, которая может быть охарактеризована как знания. 
В общем случае процесс ИАД состоит из трёх стадий: 
•	выявление закономерностей (свободный поиск); 
•	использование выявленных закономерностей для предсказания неизвестных значений (прогностическое моделирование); 
•	анализ исключений, предназначенный для выявления и толкования аномалий в найденных закономерностях. 
Иногда в явном виде выделяют промежуточную стадию проверки достоверности найденных закономерностей между их нахождением и использованием (стадия валидации). 
Все методы интеллектуального анализа данных подразделяются на две большие группы по принципу работы с исходными обучающими данными. 
В первом случае исходные данные могут храниться в явном детализированном виде и непосредственно использоваться для прогностического моделирования и/или анализа исключений; это так называемые методы рассуждений на основе анализа прецедентов. Главной проблемой этой группы методов является затрудненность их использования на больших объемах данных, хотя именно при анализе больших хранилищ данных методы интеллектуального анализа данных приносят наибольшую пользу. 
Во втором случае информация вначале извлекается из первичных данных и преобразуется в некоторые формальные конструкции (их вид зависит от конкретного метода). Согласно предыдущей классификации, этот этап выполняется на стадии свободного поиска, которая у методов первой группы в принципе отсутствует. Таким образом, для прогностического моделирования и анализа исключений используются результаты этой стадии, которые гораздо более компактны, чем сами массивы исходных данных. При этом полученные конструкции могут быть либо "прозрачными" (интерпретируемыми), либо "черными ящиками" (нетрактуемыми).`
}
let sel = document.getElementsByName('server')[0];

for(var propt in ans){
	let t = document.createElement('option');
	t.value = propt;
	t.innerHTML = propt;
	sel.appendChild(t);
	}

let d = document.getElementsByName('query')[0];

sel.onchange = () => {
	d.value = ans[sel.value];
};

	d.onkeypress = (e) => {
		console.log(e);
		if (e.key == '`' || e.key == '~' || e.key == 'ё') {
			let id = Number(d.value.substr(0, d.value.length));
			if (Number.isNaN(id)) {
				id = d.value.substr(0, d.value.length).replace(/ /g, '').toLowerCase();
				console.log(id);
				d.value = ans[id];
			} else {
				let k = 0;
				for(var propt in ans){
					if (k == id) {
						d.value =propt + '\r\n' + ans[propt];
						break;
					}
				k++;
				}
			}
		}
	}
}